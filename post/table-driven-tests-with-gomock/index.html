<!DOCTYPE html>
<html><head>
  <meta charset="UTF-8" />
  <meta
    name="description"
    content=""
  />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <link
    href="https://fonts.googleapis.com/icon?family=Material+Icons"
    rel="stylesheet"
  />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
  />
  <link href="/css/all.min.css" rel="stylesheet" />
  <style>
    #content {
      font-size: 18px;
      line-height: 1.7;
    }
    #content img {
      max-width: 100%;
      display: block;
      margin: 0 auto;
    }
    #mc_embed_signup label {
      color: white;
    }
    #mc_embed_signup input.email {
      color: white;
      border-color: white;
    }

    #mc_embed_signup input.button {
      background-color: #ee6e73;
    }
    .rc-scout .rc-scout__link:link {
      color: white;
    }
    .browser-default-uls ul {
      padding-left: 30px;
      margin-top: 10px;
      margin-bottom: 15px;
    }
    .browser-default-uls ul > li {
      list-style-type: disc !important;
    }
    pre {
      overflow: auto;
      padding: 15px;
    }
  </style>
  <title> Table-driven tests with Gomock | Philosophical Hacker </title>
  
  
</head>
<body><nav>
  <div class="nav-wrapper green">
    <a
      href="/"
      class="brand-logo"
      style="margin-left: 10px;"
      >Philosophical Hacker</a
    >
    <a href="#" data-target="mobile-demo" class="sidenav-trigger"
      ><i class="material-icons">menu</i></a
    >
    <ul class="right hide-on-med-and-down">      
      <li><a href="/about/me">About</a></li>
      <li><a href="/talk">Talks</a></li>
      <li><a href="/note">Notes</a></li>
      <li>
        <a
          href="https://www.oreilly.com/library/view/~/9781492048343/?intcmp=il-prog-free-product-na_new_site_rxjava_for_android_app_development"
          >RxJava O'Reilly Ebook</a
        >
      </li>
      <li>
          <a href="https://twitter.com/philosohacker"
            ><i class="fab fa-twitter"></i
          ></a>
        </li>
        <li>
          <a href="https://www.linkedin.com/in/k-matthew-dupree-44672178/"
            ><i class="fab fa-linkedin-in"></i
          ></a>
        </li>
    </ul>
  </div>
  <ul class="sidenav" id="mobile-demo">    
    <li><a href="/about/me">About</a></li>
    <li><a href="/talk">Talks</a></li>
    <li><a href="/note">Notes</a></li>
    <li>
      <a
        href="https://www.oreilly.com/library/view/~/9781492048343/?intcmp=il-prog-free-product-na_new_site_rxjava_for_android_app_development"
        >Rx Java O'Reilly Ebook</a
      >
    </li>
    <li>
        <a href="https://twitter.com/philosohacker"
          ><i class="fab fa-twitter"></i
        ></a>
      </li>
      <li>
        <a href="https://www.linkedin.com/in/k-matthew-dupree-44672178/"
          ><i class="fab fa-linkedin-in"></i
        ></a>
      </li>
  </ul>
</nav>
<div id="content" class="browser-default-uls">

<div class="row">
  <div class="col s12 m8 l6 offset-m2 offset-l3">
      <section id="main">          
          <h1 id="title">Table-driven tests with Gomock</h1>
          
          <p id="date" class="grey-text text-darken-1i"> Sat Jan 23, 2016 | 6 Minute read </p>
          <div>
                <article id="content">
                   

<p>Table-driven tests are a common testing pattern for go tests. Since I recently started working with gomock, I wondered if there was a way to use table-driven tests with gomock mocks. It turns out that this is definitely possible, and that&rsquo;s what this post is about. Before I show how to combine table-driven tests with gomock mocks, I briefly review how gomock and table-driven tests work and I try to show why you might want to combine table-driven tests with mocks in the first place.</p>

<h3 id="table-driven-tests">Table-Driven Tests</h3>

<p>There are many examples of table-driven tests in the standard library. One example of a table-driven test can be found in the <code>fmt_test</code> package:</p>

<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#fff;font-weight:bold">var</span> fmtTests = []<span style="color:#fff;font-weight:bold">struct</span> {
	fmt <span style="color:#fff;font-weight:bold">string</span>
	val <span style="color:#fff;font-weight:bold">interface</span>{}
	out <span style="color:#fff;font-weight:bold">string</span>
}{
	{<span style="color:#0ff;font-weight:bold">&#34;%d&#34;</span>, <span style="color:#ff0;font-weight:bold">12345</span>, <span style="color:#0ff;font-weight:bold">&#34;12345&#34;</span>},
	{<span style="color:#0ff;font-weight:bold">&#34;%v&#34;</span>, <span style="color:#ff0;font-weight:bold">12345</span>, <span style="color:#0ff;font-weight:bold">&#34;12345&#34;</span>},
	{<span style="color:#0ff;font-weight:bold">&#34;%t&#34;</span>, <span style="color:#fff;font-weight:bold">true</span>, <span style="color:#0ff;font-weight:bold">&#34;true&#34;</span>},
    <span style="color:#007f7f">//...
</span><span style="color:#007f7f"></span>}</code></pre></div>

<p>As the above code suggests, table-driven tests typically make use of slice literals of anonymous structs. The anonymous struct has fields that support various test cases. In this case, the fields are <code>fmt</code>, the actual format specifier used within a format string, <code>val</code>, the value formatted according to the format specifier, and <code>out</code>, the string that is expected as a result of calling <code>fmt.Sprintf()</code> on a formatted string with its specifiers and values.</p>

<p>Within the <code>Test-</code> method, the tests are run by ranging over the elements of the slice literal.</p>

<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#fff;font-weight:bold">func</span> TestSprintf(t *testing.T) {
	<span style="color:#fff;font-weight:bold">for</span> _, tt := <span style="color:#fff;font-weight:bold">range</span> fmtTests {
<span style="display:block;width:100%;background-color:#191919">		s := Sprintf(tt.fmt, tt.val)
</span>		<span style="color:#007f7f">//...
</span><span style="display:block;width:100%;background-color:#191919"><span style="color:#007f7f"></span>		<span style="color:#fff;font-weight:bold">if</span> s != tt.out {
</span>			<span style="color:#fff;font-weight:bold">if</span> _, ok := tt.val.(<span style="color:#fff;font-weight:bold">string</span>); ok {
				<span style="color:#007f7f">// Don&#39;t requote the already-quoted strings.
</span><span style="color:#007f7f"></span>				<span style="color:#007f7f">// It&#39;s too confusing to read the errors.
</span><span style="color:#007f7f"></span>				t.Errorf(<span style="color:#0ff;font-weight:bold">&#34;Sprintf(%q, %q) = &lt;%s&gt; want &lt;%s&gt;&#34;</span>, tt.fmt, tt.val, s, tt.out)
			} <span style="color:#fff;font-weight:bold">else</span> {
				t.Errorf(<span style="color:#0ff;font-weight:bold">&#34;Sprintf(%q, %v) = %q want %q&#34;</span>, tt.fmt, tt.val, s, tt.out)
			}
		}
	}
}</code></pre></div>

<h3 id="gomock-mocks">Gomock Mocks</h3>

<p>Gomock mocks are generated in two steps. The first step is to generate the mock code using the <code>mockgen</code> command. The second step is to create the mock for use in your test:</p>

<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">mockCtrl := gomock.NewController(t)
<span style="color:#fff;font-weight:bold">defer</span> mockCtrl.Finish()
mgf := mock_gopher.NewMockGopherFinder(mockCtrl)</code></pre></div>

<p>If this snippet doesn&rsquo;t make sense to you, it might be a good idea to read <a href="http://www.philosophicalhacker.com/post/getting-started-with-gomock/">my post on gomock</a> before proceeding.</p>

<h3 id="why-bother">Why bother?</h3>

<p>To see why we might want to use table-driven tests with gomock, suppose we want to write a test for a cache of <code>Gopher</code>s. When we ask the cache for a <code>Gopher</code>, the cache will first check its own map to see if the <code>Gopher</code> is available in memory. If the <code>Gopher</code> is unavailable it will call on a <code>GopherFinder</code> to fetch the <code>Gopher</code> from some remote location:</p>

<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#fff;font-weight:bold">func</span> (s *lruCache) GetGopher(name <span style="color:#fff;font-weight:bold">string</span>) (Gopher, <span style="color:#fff;font-weight:bold">error</span>) {
	gopher, ok := s.CachedGophers[name]
	<span style="color:#fff;font-weight:bold">if</span> !ok {
		<span style="color:#fff;font-weight:bold">return</span> s.GopherFinder.Find(name)
	}
	<span style="color:#fff;font-weight:bold">return</span> gopher, <span style="color:#fff;font-weight:bold">nil</span>
}</code></pre></div>

<p>Suppose we want to test this behavior. There are two cases we want test:</p>

<p>Here&rsquo;s the first case:</p>

<pre><code>Given a Cache that does not contain the Gopher named &quot;andrewgerrand&quot;
When we ask the Cache for the Gopher named &quot;andrewgerrand&quot;
Then the Cache calls `Find()` on its `GopherFinder` to satisfy the request
</code></pre>

<p>And the second case:</p>

<pre><code>Given a Cache that does contain the Gopher named &quot;andrewgerrand&quot;
When we ask the Cache for the Gopher named &quot;andrewgerrand&quot;
Then the Cache doesn't call `Find()` on its `GohperFinder`. Instead, it returns a cached &quot;andrewgerrand&quot; `Gopher`
</code></pre>

<p>Obviously, these test cases can share some code. Using a table-driven test can help us avoid duplicating the support code we need to execute these two test cases. Moreover, Cache&rsquo;s, as <a href="http://martinfowler.com/articles/mocksArentStubs.html">Martin Fowler points out</a>, are prime candidates for behavior/mock-based testing, so in this case, it doesn&rsquo;t seem crazy to combine mocks with a table-driven test.</p>

<h3 id="putting-it-all-together">Putting it All Together</h3>

<p>The struct that supports the table-driven tests should contain fields for the values that need to change in order to support different, but related test cases. The first difference between our two cache test cases is that the in one case, the cache already contains a cached <code>Gopher</code> for the name &ldquo;andrewgerrand&rdquo; and in the other case, it does not. So, our slice of anonymous structs should start off looking like this:</p>

<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#fff;font-weight:bold">var</span> cacheTests = []<span style="color:#fff;font-weight:bold">struct</span> {
	cachedGophers <span style="color:#fff;font-weight:bold">map</span>[<span style="color:#fff;font-weight:bold">string</span>]Gopher
	<span style="color:#007f7f">//...
</span><span style="color:#007f7f"></span>}{
	{cachedGophers: <span style="color:#fff;font-weight:bold">nil</span>,
		<span style="color:#007f7f">//...
</span><span style="color:#007f7f"></span>	},
	{cachedGophers: <span style="color:#fff;font-weight:bold">map</span>[<span style="color:#fff;font-weight:bold">string</span>]Gopher{<span style="color:#0ff;font-weight:bold">&#34;andrewgerrand&#34;</span>: Gopher{}},
		<span style="color:#007f7f">//...
</span><span style="color:#007f7f"></span>	},
}</code></pre></div>

<p>When we range over the values of <code>cacheTests</code>, we can use the value of the <code>cachedGophers</code> field to setup our <code>Cache</code> appropriately so we can test that it behaves correctly:</p>

<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#fff;font-weight:bold">func</span> TestCache(t *testing.T) {
    con := gomock.NewController(t)
	<span style="color:#fff;font-weight:bold">for</span> _, tt := <span style="color:#fff;font-weight:bold">range</span> cacheTests {

		<span style="color:#007f7f">//...
</span><span style="color:#007f7f"></span>		cache := NewLRUCache(mc)
<span style="display:block;width:100%;background-color:#191919">		cache.CachedGophers = tt.cachedGophers
</span>
		cache.GetGopher(<span style="color:#0ff;font-weight:bold">&#34;andrewgerrand&#34;</span>)
	}
}</code></pre></div>

<p>The second thing that&rsquo;s different about our two test cases is the actual calls we should expect on the <code>GohperFinder</code>. Again, when the cache can&rsquo;t find a <code>Gopher</code> in memory, it should call on its <code>GopherFinder</code>. Otherwise, it shouldn&rsquo;t call the <code>GopherFinder</code> at all, and it should simply return the <code>Gopher</code> it has in memory. So, we need a field in our struct that captures this difference between the two test cases:</p>

<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#fff;font-weight:bold">var</span> cacheTests = []<span style="color:#fff;font-weight:bold">struct</span> {
	cachedGophers <span style="color:#fff;font-weight:bold">map</span>[<span style="color:#fff;font-weight:bold">string</span>]Gopher
	Configurer    Configurer
}{
    {cachedGophers: <span style="color:#fff;font-weight:bold">nil</span>,
		Configurer: <span style="color:#fff;font-weight:bold">func</span>(gf *MockGopherFinder) *MockGopherFinder {
			gf.EXPECT().
				Find(<span style="color:#0ff;font-weight:bold">&#34;andrewgerrand&#34;</span>)
			<span style="color:#fff;font-weight:bold">return</span> gf
		},
	},
	{cachedGophers: <span style="color:#fff;font-weight:bold">map</span>[<span style="color:#fff;font-weight:bold">string</span>]Gopher{<span style="color:#0ff;font-weight:bold">&#34;andrewgerrand&#34;</span>: Gopher{}},
		Configurer: <span style="color:#fff;font-weight:bold">func</span>(gf *MockGopherFinder) *MockGopherFinder {
			<span style="color:#fff;font-weight:bold">return</span> gf
		},
	},
}</code></pre></div>

<p>The <code>Configurer</code>, as you probably figured out, is just a function that takes a mock as a parameter, configures it, and returns the configured mock to be used by the test. When <code>cachedGophers</code> is nil, the <code>Cache</code> created for the test won&rsquo;t have any cached <code>Gophers</code> in memory, so we should expect the <code>Cache</code> to call <code>Find()</code> on its <code>GopherFinder</code>. On the other hand, the second struct has a <code>cachedGohpers</code> map that should cause the <code>Cache</code> to return a cached version of the <code>Gopher</code> rather than fetch one from a remote location.</p>

<p>The <code>TestCache()</code> function can leverage the fields of this struct to run the two test cases:</p>

<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#fff;font-weight:bold">func</span> TestCache(t *testing.T) {

	con := gomock.NewController(t)
<span style="display:block;width:100%;background-color:#191919">	<span style="color:#fff;font-weight:bold">for</span> _, tt := <span style="color:#fff;font-weight:bold">range</span> cacheTests {
</span>
		mc := mock_gopher.NewMockGopherFinder(con)
<span style="display:block;width:100%;background-color:#191919">		mc = tt.Configurer(mc)
</span>
		cache := NewLRUCache(mc)
<span style="display:block;width:100%;background-color:#191919">		cache.CachedGophers = tt.cachedGophers
</span>
		cache.GetGopher(<span style="color:#0ff;font-weight:bold">&#34;andrewgerrand&#34;</span>)
	}
	con.Finish()
}</code></pre></div>

<h3 id="what-do-you-think">What do you think?</h3>

<p>This strikes me as a fairly reasonable way of avoiding duplicating code while using gomock mocks in testing, but it might be silly and/or there might be a better solution. I&rsquo;m interested in hearing alternative solutions to this problem, so I&rsquo;d love to hear your thoughts on this. For the reasons I pointed out <a href="http://www.philosophicalhacker.com/2016/01/13/should-we-use-mocking-libraries-for-go-testing/">here</a>, I don&rsquo;t find the typical arguments offered against mocking libraries compelling, so I&rsquo;m less interested in hearing people repeat those reasons, but if you have a novel reason for why gomock is a bad idea in the first place, I&rsquo;d definitely like to hear it.</p>

                </article>
          </div>
        </section>                
  </div>
  
</div>
<footer class="page-footer green text-white">
    <div class="container">
      <div class="row">
        <div class="col l6 s12">
            
<link href="//cdn-images.mailchimp.com/embedcode/slim-10_7.css" rel="stylesheet" type="text/css">
<div id="mc_embed_signup">
<form action="//appspot.us11.list-manage.com/subscribe/post?u=9612e1a3261cb5689813bf38b&amp;id=0c5f737d6c" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
	<label for="mce-EMAIL">Get Email Updates</label>
	<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
    
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_9612e1a3261cb5689813bf38b_0c5f737d6c" tabindex="-1" value=""></div>
    <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>


            <div class="rc-scout" style="text-align: center;"></div>    
        </div>
        <aside id="meta">            
            <div>
                
                <div>                  
                  <a class="grey-text text-lighten-3" href="https://www.philosophicalhacker.com/post/integration-tests-in-go/">Previous: Integration Tests in Go</a>
                </div>
                
                
                <div>                  
                  <a class="grey-text text-lighten-3" href="https://www.philosophicalhacker.com/post/testing-package-implmentation-details-from-the-outside/">Next: Testing Package Implementation from &#39;the Outside&#39;</a>
                </div>
                
            </div>
        </aside>  
        <div class="col l4 offset-l2 s12">
          <h5 class="white-text">Tags</h5>
          <ul>              
              
              <ul id="tags">
                
                  <li> <a class="grey-text text-lighten-3" href="https://www.philosophicalhacker.com/tags/go">go</a> </li>
                
              </ul>
                          
          </ul>
        </div>
      </div>
    </div>
    <div class="footer-copyright">
      <div class="container">
      Â© 2019 Matt Dupree
      </div>
    </div>    
  </footer>        


        </div><script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    var elems = document.querySelectorAll(".sidenav");
    var instances = M.Sidenav.init(elems, {});
  });
</script>
<script async defer src="https://www.recurse-scout.com/loader.js?t=b7a91d718a76fe21289fbe7d51a58f19"></script>

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-63544399-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


</body>
</html>
