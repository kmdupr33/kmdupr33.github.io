<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8"><meta name="generator" content="Hugo 0.73.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Patterns Principles and Tools for Testing Your React (Native) Apps&nbsp;&ndash;&nbsp;Philosophical Hacker</title><link rel="stylesheet" href="/css/core.min.77d0f824e1a92cc02ada741cc35eff5cc5d09aa7c4611cbf184a3cdd93e2765640409b967708af3b6ef2c9a118e4a838.css" integrity="sha384-d9D4JOGpLMAq2nQcw17/XMXQmqfEYRy/GEo83ZPidlZAQJuWdwivO27yyaEY5Kg4"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Patterns Principles and Tools for Testing Your React (Native) Apps" />
<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=document.createElement("script");r.type="text/javascript",r.async=!0,r.src="https://cdn.heapanalytics.com/js/heap-"+e+".js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(r,a);for(var n=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","resetIdentity","removeEventProperty","setEventProperties","track","unsetEventProperty"],o=0;o<p.length;o++)heap[p[o]]=n(p[o])};
  heap.load("2872977926");
</script>
<script type="application/javascript">
  (function(b,o,n,g,s,r,c){if(b[s])return;b[s]={};b[s].scriptToken="Xy0yMDEzNTMyMTI3";b[s].callsQueue=[];b[s].api=function(){b[s].callsQueue.push(arguments);};r=o.createElement(n);c=o.getElementsByTagName(n)[0];r.async=1;r.src=g;r.id=s+n;c.parentNode.insertBefore(r,c);})(window,document,"script","https://cdn.oribi.io/Xy0yMDEzNTMyMTI3/oribi.js","ORIBI");
</script>

</head>

<body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Philosophical Hacker</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/about/me">About</a><a class="nav item" href="/talk">Talks</a><a class="nav item" href="https://www%2eoreilly%2ecom/programming/free/rxjava-for-android-app-development%2ecsp?intcmp=il-prog-free-product-na_new_site_rxjava_for_android_app_development"target="_blank">RxJava O&#39;Reilly Book</a><a class="nav item" href="/note">Notes</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Patterns Principles and Tools for Testing Your React (Native) Apps</h1><p class="article date">2018-05-18</p></section><article class="article markdown-body"><p><em>Here&rsquo;s a written version of <a href="https://www.meetup.com/React-Orlando/events/250432406/"target="_blank">my recent React Orlando talk:</a></em></p>
<p>I want to talk about some patterns, principles, and tools for testing react native applications. I&rsquo;m going to focus a lot on the &ldquo;patterns and principles&rdquo; part of the testing equation because, as we all know, the improper use of tools can actually be worse than not having those tools at all.</p>
<p>Michael Scott&rsquo;s misuse of the fork-lift in Daryl&rsquo;s warehouse came to mind while I was pondering this truth, and it turns out there&rsquo;s a gif of this exact moment in the show. Behold:</p>
<p><img  src="https://media.giphy.com/media/cVkNnP1V4fvBC/giphy.gif"
        alt="Michael Scott accidentally wrecking the warehouse with a forklift"/></p>
<p>Of course, there are more serious and more relevant examples of how unprincipled usage of tools can lead to bad outcomes. Here&rsquo;s a great one from <em>xUnit Test Patterns</em>:</p>
<blockquote>
<p>Without this discovery [of how to write tests effectively] we would, at best, have abandoned the automated tests that we had already built. At worst, the tests would have reduced our productivity so much that we would have been unable to deliver on our commitments to the client.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
</blockquote>
<p>So we&rsquo;ll focus on patterns and principles to avoid this kind of situation.<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<p>Another quick caveat: I&rsquo;ll be talking a lot about react native, but insofar as I focus on principles and patterns, I&rsquo;m hoping you&rsquo;ll find insights that&rsquo;ll apply to straight React apps and to all apps you find yourself working on.</p>
<p>I like to start my talks with TLDRs that map out what we&rsquo;ll cover. Here&rsquo;s your map for tonight üó∫Ô∏è:</p>
<blockquote>
<p>You should test. Sometimes ‚ÄúUI‚Äù tests are helpful. UI tests should be grey-box. DI + Stubbing can make UI tests faster, less flaky, and more supportive of debugging. Page Object pattern can make tests less brittle and more readable.</p>
</blockquote>
<h2 id="you-should-test">You should test</h2>
<p>Presumably, you wouldn&rsquo;t be here if you weren&rsquo;t somewhat amenable to testing already, so I&rsquo;ll keep the preaching on why you should test light. Just two quick points.</p>
<p>First, I think everyone knows that testing helps us be confident that our code isn&rsquo;t broken. I think what&rsquo;s a bit less understood is just how transformational this confidence can be when it&rsquo;s achieved at scale. I didn&rsquo;t fully realize this myself until I saw Mark Zuckerberg talk about how important testing is for Facebook. Here&rsquo;s the relevant quote from Zuck:</p>
<p><img  src="/images/patterns-principles-and-tools-for-testing-react-native-apps/FunctionalTestingForReactNativeApps.009.jpeg"
        alt="Zuckerberg discussing testing"/></p>
<p>Fun fact: Kent Beck used to work at a facebook, so it makes sense that facebook has managed to achieve such amazing results with their testing infrastructure given that they&rsquo;ve got the guy who basically invented our automated testing practices as we know them today.</p>
<p>Here&rsquo;s a second, less appreciated reason, that testing is worth doing. It actually helps with the architecture of your applications. Here&rsquo;s the quote from <em>Growing Object Oriented Software Guided by Tests</em> that I love to throw around on this subject:</p>
<blockquote>
<p>for a class to be easy to unit-test, the class must‚Ä¶be loosely coupled and highly cohesive ‚Äîin other words, well-designed.<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
</blockquote>
<p>So, tests help you write better code and they help you sleep at night üò¥.</p>
<h2 id="sometimes-ui-tests-are-helpful">Sometimes &ldquo;UI&rdquo; tests are helpful</h2>
<p>So, unit tests are great. In fact, as we&rsquo;ll see in a bit, the majority of our test suite should be made up of unit tests, but one problem with unit tests is that you can wind up in this kind of situation:</p>
<p><img  src="/images/patterns-principles-and-tools-for-testing-react-native-apps/FunctionalTestingForReactNativeApps.013.jpeg"
        alt="Sinking ship with passing unit tests"/></p>
<p>So, you can have a bunch of passing unit tests, but your app can still be completely broken in the grand scheme. Now, Martin Fowler actually has a nice quote about what to do in cases where you&rsquo;ve got failing high level tests but no corresponding unit test warning you about the failure:</p>
<p><img  src="/images/patterns-principles-and-tools-for-testing-react-native-apps/FunctionalTestingForReactNativeApps.014.jpeg"
        alt="Martin Fowler on high-level tests"/></p>
<p>The reasoning behind this advice is actually the same reasoning that leads to this testing pyramid floating around on the internets describing a sort of gold ratio of test types:</p>
<p><img  src="/images/patterns-principles-and-tools-for-testing-react-native-apps/FunctionalTestingForReactNativeApps.015.jpeg"
        alt="Testing Pyramid"/></p>
<p>This pyramid is trying to point out that most of your tests should be unit tests. These are fast tests that are testing small pieces of your code. Integration tests, according to pyramid, should make up the second largest set of tests in your suite. These tests test the integration points between your app and other services like a rest API or a database. Finally, at the top we have our End-to-end tests or &ldquo;UI tests.&rdquo;</p>
<p>The first principle guiding this &ldquo;golden ratio&rdquo; of test types is that we want tests that are fast üèéÔ∏è, reliable, and that exhibit high defect localization.</p>
<p>&ldquo;Defect localization&rdquo; is a fancy term for talking how much information a test gives us about where the defect in our code is to be found. If an end-to-end test fails, you could be searching üîçÔ∏è through thousands of lines of code for your bug. If a unit tests fails, on the other hand, the test may tell you the exact line of your buggy instruction.</p>
<p>However, we also want tests that have a high chance of catching as many major issues as possible. This is the second principle guiding the test pyramid. Integration and End-to-End tend to shine here, so we trade off speed, stability, and defect localization for more confidence that our system is working correctly.</p>
<p>We&rsquo;re going to be focusing on UI and End-2-End tests tonight in particular. These two types of tests, as we&rsquo;ll see, are not exactly the same thing, even though the pyramid suggests otherwise.<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></p>
<h2 id="ui-tests-should-be-grey-box">UI tests should be grey-box</h2>
<p>To understand what I mean when I say that UI tests should be &ldquo;grey-box,&rdquo; let&rsquo;s talk about three different ways we might write a test for an app that should display a list once you login. The tricky thing about this test is that the app is going to make some network requests during the test, and we have to make sure we aren&rsquo;t asserting that the app should be displaying a list too quickly.</p>
<p>If we&rsquo;re writing a black-box test, we&rsquo;d write a test that <em>knows nothing</em> about the system that its testing. We&rsquo;d probably use appium, and we&rsquo;d probably wind up with something like this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">it(<span style="color:#f00">&#34;</span>should display a list on login<span style="color:#f00">‚Äù</span>, <span style="color:#fff;font-weight:bold">function</span> () {
<span style="display:block;width:100%;background-color:#191919">  <span style="color:#fff;font-weight:bold">this</span>.timeout(<span style="color:#ff0;font-weight:bold">300000</span>);
</span>  <span style="color:#fff;font-weight:bold">return</span> driver
    .elementByAccessibilityId(<span style="color:#0ff;font-weight:bold">&#39;LoginButton&#39;</span>)
    .click()
    .elementByAccessibilityId(<span style="color:#f00">‚Äò</span>ProductList<span style="color:#f00">‚Äô</span>)
      .should.eventually.exist
});
</code></pre></div>
<p>The problem with this test is this timeout line here. The problem is that we actually have no idea what should be passed in to this timeout method. We can find a decent value with trial and error, but that value could change it the network is a bit slower. If the network is especially slow, our test will fail inappropriately. üòû</p>
<p>A white-box test has intimate knowledge of the &ldquo;System Under Test&rdquo; (SUT) and its inner workings. Usually white-box tests are unit tests although I think the concepts are really orthogonal.</p>
<p>A grey-box test, as the name implies, has some knowledge of the SUT. If we were writing a grey-box test for the same functionality, it&rsquo;d look like this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">it(<span style="color:#0ff;font-weight:bold">&#39;should display a list on login&#39;</span>, async () =&gt; {
  await element(by.id(<span style="color:#0ff;font-weight:bold">&#39;loginInput&#39;</span>)).typeText(<span style="color:#0ff;font-weight:bold">&#39;email@gmail.com&#39;</span>);
  await element(by.id(<span style="color:#0ff;font-weight:bold">&#39;passwordInput&#39;</span>)).typeText(<span style="color:#0ff;font-weight:bold">&#39;test12345&#39;</span>);
  await element(by.id(<span style="color:#0ff;font-weight:bold">&#39;loginButton&#39;</span>)).tap();    
  await expect(element(by.id(<span style="color:#0ff;font-weight:bold">&#39;ProductList&#39;</span>))).toBeVisible();
});
</code></pre></div>
<p>Notice that we don&rsquo;t need to set a timeout here. That&rsquo;s because the test actually has some knowledge of the app its testing.</p>
<p>More specifically, it knows whether the app its testing is executing a network request. When the app is executing a network request, its smart enough to know that it should be waiting for those requests to resolve before trying to act on or assert the existence of any UI elements.</p>
<p>Now sometimes the auto-synchronization in detox tests doesn&rsquo;t work perfectly. Unfortunately, right now there&rsquo;s no way to fine-tine the synchronization in detox tests, but <a href="https://github.com/wix/detox/blob/master/docs/Troubleshooting.Synchronization.md#tweaking-and-fine-tuning-the-synchronization-mechanisms"target="_blank">they&rsquo;re working on a solution for this</a>.</p>
<p>It looks like there&rsquo;s a trend in testing towards grey-box tests. üìà</p>
<p>Google has released Espresso and EarlGrey for grey-box Android and iOS testing. The test code that we&rsquo;re looking at here is test from a grey-box Wix library called &ldquo;detox&rdquo; that&rsquo;s actually built on top of both of these technologies. Finally, it looks like appium is working on a driver based on Espresso to take advantage of its auto-syncing capabilities.</p>
<p>So, that&rsquo;s what the cool kids are doing these days, and its easy to see why. Auto-syncing makes your tests less noisy and flaky. So, your UI tests should be grey-box.</p>
<h2 id="di--stubbing-can-make-ui-tests-faster-and-more-useful">Di + Stubbing can make UI tests faster and more useful</h2>
<p>Now, even with auto-syncing that&rsquo;s available with detox, your UI tests can still be flaky. (Again, imagine a case where the network is down temporarily.) Even if your network works perfectly, your end-to-end tests can be pretty slow because of those same network requests. Even if the slow speed of test doesn&rsquo;t bother you too much, you also have a test with bad defect localization.</p>
<p>You can solve all of these problems with dependency injection and stubbing.</p>
<h3 id="what-is-dependency-injection">What is dependency injection?</h3>
<p>If you&rsquo;re not familiar with dependency injection, think about water for a second:</p>
<p><img  src="/images/patterns-principles-and-tools-for-testing-react-native-apps/FunctionalTestingForReactNativeApps.041.jpeg"
        alt="water"/></p>
<p>Water is a dependency for us to exist, right? If we&rsquo;re in good health, we can reach out and grab our own water. On the other hand, if we&rsquo;re sick, we&rsquo;ll have to get hooked up to an IV and someone will be responsible for injecting the water into our bodies.</p>
<p>With that in mind, let&rsquo;s look at some code:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="display:block;width:100%;background-color:#191919"><span style="color:#fff;font-weight:bold">import</span> productsService from <span style="color:#0ff;font-weight:bold">&#39;../productsService&#39;</span>;
</span>
<span style="color:#fff;font-weight:bold">class</span> ShopProductsList <span style="color:#fff;font-weight:bold">extends</span> Component {
  componentDidMount() {
<span style="display:block;width:100%;background-color:#191919">    productsService.fetchProducts()
</span>      .then((response) =&gt; {
         <span style="color:#fff;font-weight:bold">this</span>.setState({ products: response.items });
      })
      .<span style="color:#fff;font-weight:bold">catch</span>(error =&gt; console.log(<span style="color:#0ff;font-weight:bold">`error: </span><span style="color:#0ff;font-weight:bold">${</span>error<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">`</span>));
  }
</code></pre></div>
<p>This <code>ShopProductsList</code> depends on a <code>productsService</code>. Its reaching out a grabbing its own dependency.</p>
<p>Contrast that with this way the <code>ShopProductsList</code> gets its <code>productsService</code>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#fff;font-weight:bold">class</span> ShopProductsList <span style="color:#fff;font-weight:bold">extends</span> Component {
  componentDidMount() {
<span style="display:block;width:100%;background-color:#191919">    <span style="color:#fff;font-weight:bold">this</span>.props.productsService.fetchProducts()
</span>      .then((response) =&gt; {
         <span style="color:#fff;font-weight:bold">this</span>.setState({ products: response.items });
      })
      .<span style="color:#fff;font-weight:bold">catch</span>(error =&gt; console.log(<span style="color:#0ff;font-weight:bold">`error: </span><span style="color:#0ff;font-weight:bold">${</span>error<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">`</span>));
  }
</code></pre></div>
<p>In this case, another thing is injecting the dependency into the <code>ShopProductsList</code> just as a nurse might setup an IV to inject water into us. üö∞</p>
<h3 id="di-in-react">DI in React</h3>
<p>Now, if you&rsquo;re going to do DI in react, there&rsquo;s a couple of things you need to pay attention to:</p>
<ol>
<li>How are you going to manage your dependency graph?</li>
<li>How are you going to get your dependencies into your components?</li>
</ol>
<p>When I say &ldquo;graph&rdquo; here I mean graph as in &ldquo;graphql&rdquo; or graphs in discrete mathematics. Here&rsquo;s a dependency graph for our little app we&rsquo;ve been testing:</p>
<p><img  src="/images/patterns-principles-and-tools-for-testing-react-native-apps/FunctionalTestingForReactNativeApps.056.jpeg"
        alt="Dependency graph for shopping list app"/></p>
<p>This may not look like much, but if you&rsquo;re doing DI for your entire app, dependency graphs can get pretty gnarly. If you don&rsquo;t believe me, check out <a href="https://gist.github.com/yegor256/c76c06baee1f74e3100e#file-agents-java"target="_blank">this java code</a> that&rsquo;s trying to do DI injection manually.<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup></p>
<p>This is why we typically use DI libraries to help us manage them. Unfortunately, the DI tooling in javascript isn&rsquo;t very mature. We&rsquo;ve really only got two options: <a href="https://github.com/young-steveo/bottlejs"target="_blank">Bottlejs</a> and <a href="http://inversify.io/"target="_blank">Inversify</a>, and you can only use Inversify if you&rsquo;re using typescript.</p>
<p>I&rsquo;m not going to get into the detail of how these libraries work because I&rsquo;m already short on time üïóÔ∏è, but if you&rsquo;re going to do UI testing you should definitely check them out.</p>
<p>The second issue you need to worry about for doing DI in react is how you&rsquo;re going to get your dependencies into your components. For this, we can leverage the same pattern that&rsquo;s used by libraries like react-redux and react-router. <a href="https://500tech.com/blog/all/dependency-injection-in-react/"target="_blank">500 tech&rsquo;s blog post</a> does a decent job of explaining how this can work, but the gist is that you&rsquo;re going to use React&rsquo;s Context API and higher-order components.</p>
<p>I rolled my own solution for this in about 50 lines of code following this pattern, so its definitely doable.</p>
<h3 id="stubbing">Stubbing</h3>
<p>Assuming you&rsquo;ve got DI working in your app, you can actually swap out your dependencies with &ldquo;stubs,&rdquo; a fake implementation of your dependencies that return canned data to speed up and stabilize your tests.<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup> Let&rsquo;s look at an example.</p>
<p>Ordinarily, when our app runs, we&rsquo;ll be injecting üíâ a <code>ProductsService</code> that can fetch products for our list:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">&lt;ShopProductsList
  productsService={{
    fetchProducts: () =&gt; fetch(<span style="color:#f00">‚Äò‚Ä¶‚Äô</span>)
  }}
<span style="color:#f00">/&gt;</span>
</code></pre></div>
<p>However, to make our tests run more quickly and more consistently, we can cut out the network entirely ‚õîÔ∏è and inject our <code>ShopProductsList</code> component with a stub like this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">&lt;ShopProductsList
  productsService={{
    fetchProducts: () =&gt; <span style="color:#fff;font-weight:bold">Promise</span>.resolve([{...}])
  }}
<span style="color:#f00">/&gt;</span>
</code></pre></div>
<h3 id="putting-together-di-and-stubbing-for-hermetic-tests">Putting together DI and Stubbing for Hermetic tests</h3>
<p>When we cut off our app from the outside world, we&rsquo;re creating what&rsquo;s called a &ldquo;hermetic test,&rdquo; and now we can finally see why I said earlier that UI tests aren&rsquo;t necessarily the same thing as an end-to-end test. We&rsquo;re going to test our app through the UI, but we aren&rsquo;t testing our system end-to-end if we&rsquo;re doing a hermetic test.</p>
<p>Now, because we&rsquo;ve got our DI setup, we can actually configure our dependency injection differently depending on whether we&rsquo;re running the app in production or whether we&rsquo;re running tests against it. So, for example, here&rsquo;s the default index.js file that sets up our DI container with a standard <code>ProductsService</code>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#fff;font-weight:bold">import</span> initialize from <span style="color:#0ff;font-weight:bold">&#39;./js/initialize&#39;</span>;
<span style="color:#fff;font-weight:bold">import</span> { ProductsService } from <span style="color:#0ff;font-weight:bold">&#39;./js/productsService&#39;</span>;

initialize(user =&gt; <span style="color:#fff;font-weight:bold">new</span> ProductsService(user));
</code></pre></div>
<p>Next, we can create an alternative entry point called &ldquo;testIndex.js&rdquo; that sets up our DI differently so that our components are getting stub <code>ProductServices</code>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#fff;font-weight:bold">import</span> initialize from <span style="color:#0ff;font-weight:bold">&#39;./js/initialize&#39;</span>;

<span style="color:#007f7f">/* eslint no-unused-vars: off */</span>
initialize(_ =&gt; ({
  fetchProducts: () =&gt; <span style="color:#fff;font-weight:bold">Promise</span>.resolve({
    items: [
      {        
        name: <span style="color:#0ff;font-weight:bold">&#39;Earings or something&#39;</span>,
      },
      {        
        name: <span style="color:#0ff;font-weight:bold">&#39;Baby Blankets&#39;</span>,
      },
      {        
        name: <span style="color:#0ff;font-weight:bold">&#39;Stuff&#39;</span>,
      },
    ],
  }),
}));
</code></pre></div>
<p>To do this, we can leverage Xcode Schemes/Targets/Build Settings and change the entry-point that&rsquo;s used for bundling our javascript. Again, I&rsquo;m short on time here and there are plenty of blog posts that talk about how to have build variants for iOS apps<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>, so I&rsquo;m just going to gloss over this, but the gist here is you:</p>
<ol>
<li>
<p>Create a build setting called entry point. For your app target, the value of that setting is going to be index.js</p>
</li>
<li>
<p>Create a new target specifically for testing, and change the value of the build setting to a different file that configures your dependency injection differently.</p>
</li>
<li>
<p>Create a scheme for that target.</p>
</li>
<li>
<p>Expose your build setting through the Info.plist</p>
</li>
<li>
<p>Grab the value of your ENTRY_POINT build setting in your AppDelegate.m and pass it along to react native.</p>
</li>
</ol>
<p>The process for doing this on Android is similar, but I&rsquo;m not going to cover it because support for detox on Android right now isn&rsquo;t so great anyway.</p>
<h2 id="page-object-pattern-can-make-tests-less-brittle-and-more-readable">Page Object pattern can make tests less brittle and more readable</h2>
<p>There&rsquo;s a part of the testing react native apps with detox that I wasn&rsquo;t too thrilled about. This meme came to mind when I started thinking about it:</p>
<p><img  src="/images/patterns-principles-and-tools-for-testing-react-native-apps/FunctionalTestingForReactNativeApps.069.jpeg"
        alt="Picard facepalm"/></p>
<p>Remember in the above detox test where we were finding elements by id? Here&rsquo;s the code again just in case you don&rsquo;t remember this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">it(<span style="color:#0ff;font-weight:bold">&#39;should display a list on login&#39;</span>, async () =&gt; {
  await element(by.id(<span style="color:#0ff;font-weight:bold">&#39;loginInput&#39;</span>)).typeText(<span style="color:#0ff;font-weight:bold">&#39;email@gmail.com&#39;</span>);
  await element(by.id(<span style="color:#0ff;font-weight:bold">&#39;passwordInput&#39;</span>)).typeText(<span style="color:#0ff;font-weight:bold">&#39;test12345&#39;</span>);
  await element(by.id(<span style="color:#0ff;font-weight:bold">&#39;loginButton&#39;</span>)).tap();    
  await expect(element(by.id(<span style="color:#0ff;font-weight:bold">&#39;ProductList&#39;</span>))).toBeVisible();
});
</code></pre></div>
<p>Finding elements by id is actually recommended by <a href="https://github.com/wix/detox/blob/master/docs/APIRef.Matchers.md"target="_blank">the detox docs</a>:</p>
<blockquote>
<p>NOTE: Whenever possible we recommend to match elements by.id, these are more resilient to layout restructuring and text/language changes</p>
</blockquote>
<p>I think finding elements by Id is a bummer because it forces you to pollute üè≠Ô∏è your application code with test code. The id that its using for searching is the <code>testID</code> prop and here&rsquo;s what it looks like in action:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">&lt;View style={styles.container}&gt;    
    &lt;AuthTextInput
<span style="display:block;width:100%;background-color:#191919">      testID=<span style="color:#0ff;font-weight:bold">&#34;loginInput&#34;</span>
</span>      onChangeText={text =&gt; <span style="color:#fff;font-weight:bold">this</span>.setState({ ...<span style="color:#fff;font-weight:bold">this</span>.state, username: text })}
      placeholder=<span style="color:#0ff;font-weight:bold">&#34;Email&#34;</span>
      value={<span style="color:#fff;font-weight:bold">this</span>.state.username}
    /&gt;
    &lt;AuthTextInput
<span style="display:block;width:100%;background-color:#191919">      testID=<span style="color:#0ff;font-weight:bold">&#34;passwordInput&#34;</span>
</span>      placeholder=<span style="color:#0ff;font-weight:bold">&#34;Password&#34;</span>
      secureTextEntry
      onChangeText={text =&gt; <span style="color:#fff;font-weight:bold">this</span>.setState({ ...<span style="color:#fff;font-weight:bold">this</span>.state, password: text })}
      value={<span style="color:#fff;font-weight:bold">this</span>.state.password}
    /&gt;
    &lt;View style={styles.authButtonContainer}&gt;
<span style="display:block;width:100%;background-color:#191919">      &lt;AuthButton testID=<span style="color:#0ff;font-weight:bold">&#34;loginButton&#34;</span> title=<span style="color:#0ff;font-weight:bold">&#34;Login&#34;</span> onPress={<span style="color:#fff;font-weight:bold">this</span>.onLogin} /&gt;
</span>      &lt;AuthButton title=<span style="color:#0ff;font-weight:bold">&#34;Register&#34;</span> onPress={<span style="color:#fff;font-weight:bold">this</span>.onRegister} /&gt;
    &lt;<span style="color:#f00">/View&gt;</span>
&lt;<span style="color:#f00">/View&gt;</span>
</code></pre></div>
<p>Fortunately, there&rsquo;s a way of keeping your tests fairly resilient to text changes that doesn&rsquo;t require this pollution <em>and</em> it also makes your tests more readable: its called the &ldquo;page object pattern.&rdquo; The gist of the pattern is that you encapsulate your element finding code in abstractions of the screen your testing called &ldquo;pages.&rdquo; Here&rsquo;s what this would look like for the login screen that we interact with in our test:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1</span><span style="color:#fff;font-weight:bold">class</span> LoginPage {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2</span>  async enterCredentials(username, password) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3</span>    await element(by.id(<span style="color:#0ff;font-weight:bold">&#39;loginInput&#39;</span>)).typeText(username);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4</span>    await element(by.id(<span style="color:#0ff;font-weight:bold">&#39;passwordInput&#39;</span>)).typeText(password);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5</span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6</span>  }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8</span>  async login() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9</span>    await element(by.id(<span style="color:#0ff;font-weight:bold">&#39;loginButton&#39;</span>)).tap();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10</span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> ShoppingListPage();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11</span>  }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12</span>}
</code></pre></div>
<p>A couple of notes here:</p>
<ol>
<li>
<p>If calling a method interacts with a page in such a way that the user is still on that page, we return <code>this</code> so that we can chain our method call son that page object.</p>
</li>
<li>
<p>If calling a method interacts with a page in such a way that the user is moved to a different screen, we return an instance of the page class that has methods for interacting on that screen.</p>
</li>
</ol>
<p>Now we can get rid of our <code>testID</code> props if we just match elements by title instead:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#fff;font-weight:bold">class</span> LoginPage {
  async enterCredentials(username, password) {
<span style="display:block;width:100%;background-color:#191919">    await element(by.text(<span style="color:#0ff;font-weight:bold">&#39;Username&#39;</span>)).typeText(username);
</span><span style="display:block;width:100%;background-color:#191919">    await element(by.text(<span style="color:#0ff;font-weight:bold">&#39;Password&#39;</span>)).typeText(password);
</span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>;
  }

  async login() {
<span style="display:block;width:100%;background-color:#191919">    await element(by.text(<span style="color:#0ff;font-weight:bold">&#39;Login&#39;</span>)).tap();
</span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> ShoppingListPage();
  }
}
</code></pre></div>
<p>Now here&rsquo;s the kicker: if the text of our elements changes <em>its not a big deal</em> because all we have to do is update our page object instead of having to update all of our tests. The motivation for mixing test code with application code evaporates and with page objects, we get more readable tests to boot üéâ :</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">it(<span style="color:#0ff;font-weight:bold">&#39;should show products on login&#39;</span>, async () =&gt; {    
    <span style="color:#fff;font-weight:bold">new</span> LoginPage()
      .enterCredentials(<span style="color:#0ff;font-weight:bold">&#39;email@gmail.com&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;test12345&#39;</span>)
      .login()
      .assertVisible();
  });
</code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>Well, that&rsquo;s all I have. Here&rsquo;s that tldr again to sum up what we&rsquo;ve covered:</p>
<blockquote>
<p>You should test. Sometimes ‚ÄúUI‚Äù tests are helpful. UI tests should be grey-box. DI + Stubbing can make UI tests faster, less flaky, and more supportive of debugging. Page Object pattern can make tests less brittle and more readable.</p>
</blockquote>
<hr>
<h3 id="notes">Notes:</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><em>xUnit Testing Patterns</em>, 27-28. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>I think one of the things that&rsquo;s been lost in the popularization of TDD is that tests aren&rsquo;t magic: There&rsquo;s no guarantee that you can just write some code that makes assertions and wind up with a useful test suite. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><em>Growing Object Oriented Software Guided by Tests</em>, 43. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>This is just one reason why I&rsquo;m starting to think the testing pyramid is an outdated way of talking about testing strategy. Turns out there&rsquo;s <a href="https://martinfowler.com/articles/practical-test-pyramid.html"target="_blank">an article on Martin Fowler&rsquo;s blog</a> that takes the testing pyramid to task for this and other shortcomings. <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p><a href="https://www.yegor256.com/2014/10/03/di-containers-are-evil.html"target="_blank">In this post</a>, the author is actually trying to argue that we don&rsquo;t need dependency injection container&rsquo;s. We can just write these massive files that wire up all our dependencies. No thanks. <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>A lot of people would probably call this a &ldquo;mock&rdquo; instead, but <a href="https://martinfowler.com/articles/mocksArentStubs.html"target="_blank">mocks aren&rsquo;t stubs</a>. The confusion on terminology here <a href="https://www.philosophicalhacker.com/2016/01/13/should-we-use-mocking-libraries-for-go-testing/"target="_blank">has led to some confusion about the importance of mocking libraries in the go community</a>. <a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p><a href="ravelantunes.com/blog/xcode-build-process/">Here&rsquo;s one</a>. <a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
</article><section class="article labels"><a class="tag" href=/tags/testing/>testing</a><a class="tag" href=/tags/react/>react</a><a class="tag" href=/tags/react-native/>react native</a></section></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/post/internet-trends-2018/"><span class="li iconfont icon-article"></span>Mobile Down, Smart Speakers Up: 2 Notable Trends from this Year's Internet Trends Report</a></p><p><a class="link" href="/post/rest-in-2018/"><span class="li iconfont icon-article"></span>The so-called 'RESTful' web in 2018 and beyond</a></p></section><section class="article discussion"><div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "philosophicalhacker" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></section></div></section><section id="footer"><div style="display: flex; flex-direction: row; justify-content: center;">
  <p>
    &copy; 2022 Matt Dupree
  </p>
</div>
</section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-63544399-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script src="/js/core.min.e824fe5a8e6cd5e2ac09542506ccf3c3ad34d1f7503ad17867ea48f453c8e1ea9f6dfda7691546f13c99136fd4a9bd13.js" integrity="sha384-6CT&#43;Wo5s1eKsCVQlBszzw6000fdQOtF4Z&#43;pI9FPI4eqfbf2naRVG8TyZE2/Uqb0T"></script></body>

</html>