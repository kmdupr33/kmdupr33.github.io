<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kotlin on Philosophical Hacker</title>
    <link>https://www.philosophicalhacker.com/tags/kotlin/index.xml</link>
    <description>Recent content in Kotlin on Philosophical Hacker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://www.philosophicalhacker.com/tags/kotlin/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How to Abuse Kotlin Extension Functions</title>
      <link>https://www.philosophicalhacker.com/post/how-to-abuse-kotlin-extension-functions/</link>
      <pubDate>Fri, 26 May 2017 18:48:58 -0400</pubDate>
      
      <guid>https://www.philosophicalhacker.com/post/how-to-abuse-kotlin-extension-functions/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve got a &amp;ldquo;sweet tooth,&amp;rdquo; which, in my case, is just a euphemism for me saying that I&amp;rsquo;m &lt;em&gt;addicted&lt;/em&gt; to sugar. I&amp;rsquo;m young now, but I know that this addiction won&amp;rsquo;t end well once my metabolism slows down, so I try go to the gym.&lt;/p&gt;

&lt;p&gt;Unfortunately, when I leave the gym, I often think to myself, &amp;ldquo;I just worked out, so I can snag that Oreo McFlurry I&amp;rsquo;ve been craving all day.&amp;rdquo; When I do this, I abuse exercise: I take a good thing &amp;mdash; exercise &amp;mdash; and I use it to justify engaging in a bad habit &amp;mdash; consuming empty calories. Hold that thought.&lt;/p&gt;

&lt;p&gt;I started using Kotlin this week. Overall, Kotlin is absolutely delightful, but heaping unqualified additional praise on an already hyped language doesn&amp;rsquo;t make good toilet reading, so let&amp;rsquo;s mix things up a bit.&lt;/p&gt;

&lt;p&gt;I want to talk about a Kotlin language feature that I&amp;rsquo;m not thrilled about. I&amp;rsquo;m less than ecstatic about this feature because I think that its likely to be abused. Just as I can take something good like exercise and use it to justify a bad habit, we can take good Kotlin language features and use them to continue and exacerbate our bad Java coding habits into our Kotlin code.&lt;/p&gt;

&lt;p&gt;More specifically, I&amp;rsquo;m worried about extension functions. I&amp;rsquo;m worried that extensions will make it easier for us to avoid creating clean abstractions in our code. Let&amp;rsquo;s look at this in detail so that we can avoid abusing extension functions.&lt;/p&gt;

&lt;p&gt;First, we&amp;rsquo;ll look at the original intent of extension functions. Then, we&amp;rsquo;ll examine an example in &lt;a href=&#34;https://github.com/google/iosched&#34;&gt;the Google I/O codebase&lt;/a&gt; where I think extension functions are getting abused, and we&amp;rsquo;ll talk specifically about why I think we have a bona-fide example of abuse on our hands. Finally, I&amp;rsquo;ll talk about a better way of structuring the abusive code.&lt;/p&gt;

&lt;h3 id=&#34;why-extensions-are-good-thing-sometimes&#34;&gt;Why Extensions are Good Thing (sometimes)&lt;/h3&gt;

&lt;p&gt;Before we look at how extensions can be abused, let&amp;rsquo;s look at what they&amp;rsquo;re good for. &lt;a href=&#34;https://kotlinlang.org/docs/reference/extensions.html#motivation&#34;&gt;The &amp;ldquo;motivation&amp;rdquo; section of the docs on this feature&lt;/a&gt; is helpful here:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In Java, we are used to classes named &amp;ldquo;*Utils&amp;rdquo;: FileUtils, StringUtils and so on. The famous java.util.Collections belongs to the same breed. And the unpleasant part about these Utils-classes is that&amp;hellip;class names are always getting in the way.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The example they have for this is brilliant:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;Collections&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;swap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;list&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt; 
                Collections&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;binarySearch&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;list&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt; Collections&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;max&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;otherList&lt;span style=&#34;color: #666666&#34;&gt;)),&lt;/span&gt; 
                Collections&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;max&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;list&lt;span style=&#34;color: #666666&#34;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Because of the code completion and improved readability, the kotlin folks rightly point out that we&amp;rsquo;d rather write:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;list&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;swap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;list&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;binarySearch&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;otherList&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;max&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;()),&lt;/span&gt; list&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;max&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, we can&amp;rsquo;t implement all possible list methods inside of the list class, so, in order to achieve this, we need to a way to write list methods outside of the list class. And that, boys and girls, is where extension functions come from.&lt;/p&gt;

&lt;h3 id=&#34;an-example-extension-function-abuse&#34;&gt;An Example Extension Function Abuse&lt;/h3&gt;

&lt;p&gt;In some cases, this seems like a great addition to the language. Where could we go wrong here? To answer this question, let&amp;rsquo;s look at some Google I/O code that could be refactored to use extension functions, but probably shouldn&amp;rsquo;t be.&lt;/p&gt;

&lt;p&gt;The Google I/O code base contains a &lt;code&gt;SettingsUtils&lt;/code&gt; class. Its 484 lines long and has 33 methods. Yuck. Call sites of the methods on this class, moreover, don&amp;rsquo;t look great:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Ensure we don&amp;#39;t run this fragment again&lt;/span&gt;
LOGD&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;TAG&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Marking attending flag.&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;
SettingsUtils&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;setAttendeeAtVenue&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;mActivity&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;
SettingsUtils&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;markAnsweredLocalOrRemote&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;mActivity&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, using an extension method on a &lt;code&gt;Context&lt;/code&gt; might make some of this code look a little better:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// PrefExtensions.kt&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;Context&lt;/span&gt;.setAttendeeAtVenue(newValue: Boolean) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;val&lt;/span&gt; defaultSharedPreferences = PreferenceManager.getDefaultSharedPreferences(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;)
    defaultSharedPreferences.edit().putBoolean(BuildConfig.PREF_ATTENDEE_AT_VENUE, newValue).apply()
}

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;Context&lt;/span&gt;.markAnsweredLocalOrRemote(newValue: Boolean) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;val&lt;/span&gt; sp = PreferenceManager.getDefaultSharedPreferences(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;)
    sp.edit().putBoolean(PREF_ANSWERED_LOCAL_OR_REMOTE, newValue).apply()
}

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// AttendingFragment.kt&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;onClick&lt;/span&gt;(v: View) {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Ensure we don&amp;#39;t run this fragment again&lt;/span&gt;
    LOGD(TAG, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Marking attending flag.&amp;quot;&lt;/span&gt;)
    mActivity.setAttendeeAtVenue(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;true&lt;/span&gt;)
    mActivity.markAnsweredLocalOrRemote(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;true&lt;/span&gt;)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Even if you&amp;rsquo;re not crazy enough to add extension functions to &lt;a href=&#34;https://www.philosophicalhacker.com/post/towards-godless-android-development-how-and-why-i-kill-god-objects/&#34;&gt;a god object&lt;/a&gt;, you might be tempted to kotlinify this code by writing an extension function for &lt;code&gt;SharedPreferences&lt;/code&gt;. I still that that would be a mistake.&lt;/p&gt;

&lt;h3 id=&#34;why-abuse&#34;&gt;Why Abuse?&lt;/h3&gt;

&lt;p&gt;Extension functions, as their name implies, are good for &lt;em&gt;extending&lt;/em&gt; existing abstractions. They&amp;rsquo;re abused when we use them to palliate the use of a bad or entirely absent abstractions.&lt;/p&gt;

&lt;p&gt;To see why this particular example is an abuse of extension functions, let&amp;rsquo;s back up a second and think back to the &lt;code&gt;SettingsUtil&lt;/code&gt; class. &lt;code&gt;Util*&lt;/code&gt; classes, in many cases, are substitutes for missing or poorly formed abstractions. That&amp;rsquo;s true in this case.&lt;/p&gt;

&lt;p&gt;Is the attendee&amp;rsquo;s physical location in relation to the Google I/O conference a Setting? Not really.&lt;/p&gt;

&lt;p&gt;Its implemented as a &lt;code&gt;SharedPreference&lt;/code&gt;, so it gets lumped in with all the other SharedPreference-related methods in &lt;code&gt;SettingsUtils&lt;/code&gt;, but these two methods are really part of something that&amp;rsquo;s different from a &lt;code&gt;SharedPreference&lt;/code&gt;. &lt;code&gt;SharedPreference&lt;/code&gt; is just an implementation detail. &lt;code&gt;SharedPreferences&lt;/code&gt; can be a bit annoying to get a hold of, so to make matters worse, this bag of methods lives in an utility class.&lt;/p&gt;

&lt;p&gt;This has two consequences: First, &lt;code&gt;SettingsUtil&lt;/code&gt; and &lt;code&gt;AttendingFragment&lt;/code&gt; are harder to understand because they have low cohesion. Second, &lt;code&gt;SettingsUtil&lt;/code&gt; and &lt;code&gt;AttendingFragment&lt;/code&gt; are overly coupled, which will make testing and maintenance more difficult.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at cohesion-related consequences first. &lt;code&gt;SettingsUtil&lt;/code&gt; is a class that&amp;rsquo;s hard to grok because its just an random bag of 34 conceptually unrelated methods that all happen to rely on &lt;code&gt;SharedPreferences&lt;/code&gt; as an implementation detail. Because the purpose of &lt;code&gt;SettingsUtil&lt;/code&gt; is hard to understand, the purpose of &lt;code&gt;AttendingFragment&lt;/code&gt;, a class that relies on it is also obscured, albeit to a lesser degree.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the kicker: moving to extension functions doesn&amp;rsquo;t do anything to solve this problem.&lt;/p&gt;

&lt;p&gt;Next, the coupling-related consequences. &lt;em&gt;Extensions are resolved statically.&lt;/em&gt; This means that code that depends on extension methods are &lt;em&gt;tightly coupled&lt;/em&gt; to a single implementation of an extension method.&lt;/p&gt;

&lt;p&gt;Java&amp;rsquo;s static methods result in the same exact degree of coupling, and that&amp;rsquo;s the point here: moving to extension functions doesn&amp;rsquo;t really solve the deeper problem here. You&amp;rsquo;re code looks a little nicer, but its still tightly coupled.&lt;/p&gt;

&lt;p&gt;So, on both counts, using extension functions in this case merely helps us put lipstick on a pig. As I said at the outset of this section, extension functions are better used when we want to extend an already existing abstraction.&lt;/p&gt;

&lt;h3 id=&#34;a-better-way&#34;&gt;A better way&lt;/h3&gt;

&lt;p&gt;To solidify the idea that using a function extension in this case would be an abuse, let&amp;rsquo;s look at a better way of handling the above code. As far as I can tell, the missing abstraction here is an &lt;code&gt;Attendee&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Attendee&lt;/span&gt; {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Attending&lt;/span&gt; {
        IN_PERSON,
        REMOTE,
        UNKNOWN
    }

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;setAtVenue&lt;/span&gt;(newValue: Boolean)
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;attending&lt;/span&gt;(): Attending
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It turns out that there are other &lt;code&gt;SettingsUtil&lt;/code&gt; methods that make sense to move to this interface. Conference attendees accept a code of conduct that is presented in the &lt;code&gt;ConductFragment&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Attendee&lt;/span&gt; {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;acceptCodeOfConduct&lt;/span&gt;(newValue: Boolean)
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;hasAcceptedCodeOfConduct&lt;/span&gt;(): Boolean
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now that we&amp;rsquo;ve filled out the methods on this interface, we can see that the call sites of &lt;code&gt;Attendee&lt;/code&gt; methods are simpler and more easily understood than their &lt;code&gt;SettingsUtils&lt;/code&gt; counter-parts:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// AttendingFragment.kt&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;onClick&lt;/span&gt;(v: View) {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Ensure we don&amp;#39;t run this fragment again&lt;/span&gt;
    LOGD(TAG, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Marking attending flag.&amp;quot;&lt;/span&gt;)
    attendee.setAtVenue(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;true&lt;/span&gt;)    
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Notice we dont need to call SettingsUtils.markAnsweredLocalOrRemote.&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;With these changes, the &lt;code&gt;SettingsUtils&lt;/code&gt; class loses 5 methods, thereby getting a little more digestible. The &lt;code&gt;SharedPrefsAttendee&lt;/code&gt; implementation, as you can imagine, is short (24 kotlin lines) and easily grokked. Classes that use the &lt;code&gt;Attendee&lt;/code&gt; abstraction are a little clearer and a little simpler. They also aren&amp;rsquo;t tightly coupled with a specific implementation, which makes them easier to test and maintain.&lt;/p&gt;

&lt;p&gt;So, don&amp;rsquo;t abuse Kotlin&amp;rsquo;s extension functions. They&amp;rsquo;re neat, but sometimes plain old OO techniques are a better choice. Identifying a missing or bad abstraction is often a better way to approach &lt;code&gt;*Util&lt;/code&gt; classes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why Im Skeptical about Kotlin Coroutines for Android Development</title>
      <link>https://www.philosophicalhacker.com/post/why-im-skeptical-about-kotlin-coroutines-for-android-development/</link>
      <pubDate>Sun, 19 Mar 2017 00:34:58 -0400</pubDate>
      
      <guid>https://www.philosophicalhacker.com/post/why-im-skeptical-about-kotlin-coroutines-for-android-development/</guid>
      <description>

&lt;p&gt;A few weeks ago, the folks working on Kotlin announced the 1.1 release. Kotlin&amp;rsquo;s 1.1 release has experiment support for coroutines. Here&amp;rsquo;s the elevator pitch for coroutines from their blog post announcing the release:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Asynchronous programming is taking over the world, and the only thing that is holding us back is that non-blocking code adds considerable complexity to our systems. Kotlin now offers means to tame this complexity by making coroutines first-class citizens in the language through the single primitive: suspending functions. Such a function (or lambda) represents a computation that can be suspended (without blocking any threads) and resumed later.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Coroutines are neat and they may actually be very useful in many cases, but I&amp;rsquo;m not actually sure how useful they&amp;rsquo;ll be in Android development. This post is about why I&amp;rsquo;m skeptical that coroutines really matter for Android development. Here&amp;rsquo;s the short answer: I suspect that RxJava actually gives us a better way of &amp;ldquo;taming asynchronous complexity&amp;rdquo; than coroutines do.&lt;/p&gt;

&lt;h3 id=&#34;observables-give-us-an-apt-model-for-many-problems-in-android-development&#34;&gt;Observables give us an apt model for many problems in Android development&lt;/h3&gt;

&lt;p&gt;In order to see why I&amp;rsquo;m skeptical about coroutines, let&amp;rsquo;s start by noting that streams give us an &lt;em&gt;explicit&lt;/em&gt; way of modeling many problems in Android development. When you really start getting into rxjava, it changes &lt;em&gt;the way you think&lt;/em&gt; about your problems. You start to think with &lt;code&gt;Observable&lt;/code&gt;s and you realize that most of your problems are about how to compose your &lt;code&gt;Observable&lt;/code&gt;s with various operators to get the data you&amp;rsquo;re actually interested in.&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;ve stumbled upon a good way to model your problems, your life gets easier and you get to be continually amazed at how many problems your model helps you solve. Something like this happened when we started using functional programming to work with collections:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Richard Waters&amp;hellip;developed a program that automatically analyzes traditional Fortran programs, viewing them in terms of maps, filters, and accumulations. He found that fully 90 percent of the code in the Fortran Scientific Subroutine Package fits neatly into this paradigm.&lt;/p&gt;

&lt;p&gt;-Abelson et. al, Structure and Interpretation of Computer Programs&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What&amp;rsquo;s interesting is that when you find a good way to explicitly model your problems in code, you actually start to think with that model, &lt;em&gt;even if you aren&amp;rsquo;t actively using it in code.&lt;/em&gt; For example, suppose I&amp;rsquo;m looking at the following code:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;[]&lt;/span&gt; ints &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{0,&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1,&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2};&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; sum &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0;&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ints&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color: #666666&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
  ints&lt;span style=&#34;color: #666666&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color: #666666&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*=&lt;/span&gt; ints&lt;span style=&#34;color: #666666&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color: #666666&#34;&gt;];&lt;/span&gt;
&lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; anInt &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; ints&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
  sum &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; anInt&lt;span style=&#34;color: #666666&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
System&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;sum&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I think about this code by thinking in terms of maps and reduces, even if I&amp;rsquo;m not working with a Java &lt;code&gt;Stream&lt;/code&gt; that has those methods. The same is true about &lt;code&gt;Observable&lt;/code&gt;: its such a good way of modeling the problems that I face that I think in terms of it, even if I&amp;rsquo;m not lucky enough to use RxJava.&lt;/p&gt;

&lt;p&gt;Coroutines, on the other hand, dont give us any model of what we&amp;rsquo;re trying to accomplish with our asynchronous data at all. Rather, coroutines just give us a way to write code that feels &lt;em&gt;imperative,&lt;/em&gt; even if it is asynchronous. Here&amp;rsquo;s an example from the blog post announcing coroutines:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// launches new coroutine in UI context&lt;/span&gt;
launch(UI) {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// wait for async overlay to complete&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;val&lt;/span&gt; image = asyncOverlay().await()
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// and then show it in UI&lt;/span&gt;
    showImage(image)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;asyncOverlay&lt;/code&gt; does some async work, but we get to avoid writing callbacks. The code just &amp;ldquo;stops&amp;rdquo; while waiting for that async work to complete &lt;em&gt;without blocking the main thread&lt;/em&gt;. Its neat, but, again, there&amp;rsquo;s no modeling of problems that&amp;rsquo;s happening here.&lt;/p&gt;

&lt;h3 id=&#34;observable-is-a-better-abstraction-of-synchronicity&#34;&gt;Observable is a better abstraction of synchronicity&lt;/h3&gt;

&lt;p&gt;RxJava does more than just allow us to model asynchronous events and data. It actually allows us to abstract over synchronicity when we&amp;rsquo;re thinking about streams or collections of data. Ordered synchronous and asynchronous data have the same API. If we want to model sequential data in our code, when we&amp;rsquo;re using RxJava, we don&amp;rsquo;t &lt;em&gt;necessarily&lt;/em&gt; have to care whether that data arrives synchronously or asynchronously. Here&amp;rsquo;s &lt;a href=&#34;http://reactivex.io/intro.html&#34;&gt;the reactivex.io site&amp;rsquo;s&lt;/a&gt; pitch on this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The ReactiveX Observable model allows you to treat streams of asynchronous events with the same sort of simple, composable operations that you use for collections of data items like arrays. It frees you from tangled webs of callbacks, and thereby makes your code more readable and less prone to bugs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here&amp;rsquo;s something that I regularly do that demonstrates this delightful abstraction:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;clicksObservable
  &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;flatMapSingle&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;click &lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt; githubApi&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;listRepos&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;())&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;flatMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;repos &lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt; Observable&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;fromIterable&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;repos&lt;span style=&#34;color: #666666&#34;&gt;))&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;filter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;repo &lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt; isMine&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;repo&lt;span style=&#34;color: #666666&#34;&gt;))&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;subscribe&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;repo &lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt; displayInList&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;repo&lt;span style=&#34;color: #666666&#34;&gt;)})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I start with a stream of clicks and wind up with a list view that displays only the repos that aren&amp;rsquo;t mine. Along the way, I work with an &lt;code&gt;Iterable&lt;/code&gt; of repos, but I can easily turn that &lt;code&gt;Iterable&lt;/code&gt; into an &lt;code&gt;Observable&lt;/code&gt; and then it doesn&amp;rsquo;t even matter whether the repos are in memory or retrieved asynchronously. The &lt;code&gt;Observable&lt;/code&gt; cascade doesn&amp;rsquo;t get broken and the periods line up beautifully.&lt;/p&gt;

&lt;p&gt;Coroutines, on the other hand, don&amp;rsquo;t let us abstract over synchronous and asynchronous data like this. For synchronous data/operations, we use normal functions. For asynchronous data, we need to use suspecting functions wrapped in blocks that start coroutines.&lt;/p&gt;

&lt;h3 id=&#34;observables-lets-us-work-at-a-higher-level-of-abstraction&#34;&gt;Observables lets us work at a higher level of abstraction&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Observable&lt;/code&gt;s do more than just model our problems and abstract over synchronicity. They do this in a way that lets us work at a higher level of abstraction than imperative code. I can write a map an array imperatively like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;[]&lt;/span&gt; ints &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{0,&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1,&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2};&lt;/span&gt;    
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0;&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ints&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color: #666666&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
  ints&lt;span style=&#34;color: #666666&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color: #666666&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*=&lt;/span&gt; ints&lt;span style=&#34;color: #666666&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color: #666666&#34;&gt;];&lt;/span&gt;
&lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Or I can do it declaratively like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;Observable&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;fromArray&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;ints&lt;span style=&#34;color: #666666&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;map&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;aInt &lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt; aInt &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; aInt&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Coroutines, in my opinion, when used to handle problems that are well modeled by &lt;code&gt;Observable&lt;/code&gt;s are merely the for loops of the asynchronous world.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;None of this is meant to suggest that coroutines aren&amp;rsquo;t useful full stop. That&amp;rsquo;s nonsense. They have their uses. I just double that they are going to be nearly as essential to Android development as RxJava.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>