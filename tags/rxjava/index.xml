<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Philosophical Hacker</title>
    <link>http://philosophicalhacker.com/tags/rxjava/index.xml</link>
    <description>Recent content on Philosophical Hacker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://philosophicalhacker.com/tags/rxjava/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>RxLoader: Lightweight, Boilerplate-Free Data loading with Loaders and RxJava</title>
      <link>http://philosophicalhacker.com/post/rxloader-boilerplate-free-data-loading-with-loaders-and-rxjava/</link>
      <pubDate>Sat, 23 Jul 2016 15:43:29 -0400</pubDate>
      
      <guid>http://philosophicalhacker.com/post/rxloader-boilerplate-free-data-loading-with-loaders-and-rxjava/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Loaders are awesome&amp;hellip;they&amp;rsquo;re essentially the best practice implementation of asynchronous data loading in your Activities.&lt;/p&gt;

&lt;p&gt;-Reto Meier, Developing Android Apps Udacity Course

The following code should make you nervous:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BoilerplateFree&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;extends&lt;/span&gt; AppCompatActivity &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...    &lt;/span&gt;

    &lt;span style=&#34;color: #AA22FF&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;onCreate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;Bundle savedInstanceState&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;super&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;onCreate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;savedInstanceState&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;
        setContentView&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;R&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;layout&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;activity_boilerplate_free&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;
        mLoginObservable&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;subscribe&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; Action1&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;AuthManager&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;AuthResponse&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color: #AA22FF&#34;&gt;@Override&lt;/span&gt;
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;call&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;AuthManager&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;AuthResponse&lt;/span&gt; authResponse&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
                Log&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;d&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;TAG&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;call: Successfully logged in&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;                
            &lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color: #666666&#34;&gt;});&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When you see this code you should be asking, &amp;ldquo;What will happen upon a configuration change? Will the &lt;code&gt;Activity&lt;/code&gt; leak? Do we need to re-query the network just because of a configuration change?&amp;rdquo; (Hopefully, when you see this code, you&amp;rsquo;re also wondering, &lt;a href=&#34;http://www.philosophicalhacker.com/post/why-we-should-stop-putting-logic-in-activities/&#34;&gt;like I do&lt;/a&gt;, &amp;ldquo;Why are we putting logic in our &lt;code&gt;Activitys&lt;/code&gt;?&amp;ldquo;)&lt;/p&gt;

&lt;p&gt;Nervous questions aside, wouldn&amp;rsquo;t it be better if we &lt;em&gt;could&lt;/em&gt; write data loading code like this? Wouldn&amp;rsquo;t it be nice if we load data into our apps using &lt;code&gt;Observable&lt;/code&gt;s without worrying about leaking activities and/or wasting the user&amp;rsquo;s data by re-querying the network every time there was a configuration change? Wouldn&amp;rsquo;t it be nice, moreover, if we could do this without writing any boilerplate code?&lt;/p&gt;

&lt;p&gt;I think so, and in this post, I&amp;rsquo;ll introduce a &lt;em&gt;tiny&lt;/em&gt; library that&amp;rsquo;ll help us write code like this. The gist of the approach is to use Loaders &lt;em&gt;with&lt;/em&gt; RxJava. Before we get into this approach, however, lets look at some other ways that people handle asynchronous data loading in their apps so that we can see what this approach offers that other ones don&amp;rsquo;t.&lt;/p&gt;

&lt;h3 id=&#34;prior-art&#34;&gt;Prior Art&lt;/h3&gt;

&lt;h4 id=&#34;loaders&#34;&gt;Loaders&lt;/h4&gt;

&lt;p&gt;Loaders give us what we want vis-a-vis memory-leak-free querying whose results persist across orientation changes, but many people find the API clunky and/or confusing. Apparently, Jake Wharton is one of these people:&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;The fragment and loader APIs fit in perfectly on Android. Useful enough that you use them but also want shoot yourself in the face.&lt;/p&gt;&amp;mdash; Jake Wharton (@JakeWharton) &lt;a href=&#34;https://twitter.com/JakeWharton/status/325630461852413952&#34;&gt;April 20, 2013&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;retained-fragment&#34;&gt;Retained Fragment&lt;/h4&gt;

&lt;p&gt;Using a retained fragment is another approach for persisting the results of a network request across orientation changes and avoiding memory leaks. Unfortunately, this approach requires a fair amount of boiler-plate code. The barebones implementation as discussed in &lt;a href=&#34;https://developer.android.com/guide/topics/resources/runtime-changes.html&#34;&gt;the docs&lt;/a&gt; will make this clear enough. Even if we could get rid of most of this boilerplate, we still don&amp;rsquo;t have an api for working with our asynchronous data that&amp;rsquo;s as nice as RxJava&amp;rsquo;s &lt;code&gt;Observable&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;cache-replay&#34;&gt;Cache-Replay&lt;/h4&gt;

&lt;p&gt;Cache-Replay is an approach suggested in Dan Lew&amp;rsquo;s &lt;a href=&#34;http://blog.danlew.net/2014/10/08/grokking-rxjava-part-4/&#34;&gt;&amp;ldquo;Grokking RxJava Pt 4&amp;rdquo;&lt;/a&gt;. The idea here is do the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;store our &lt;code&gt;Obersvable&lt;/code&gt; outside the Activity life-cycle (e.g., a retained fragment or singleton)&lt;/li&gt;
&lt;li&gt;un-subscribe from this &lt;code&gt;Observable&lt;/code&gt; when our Activity is being destroyed&lt;/li&gt;
&lt;li&gt;use the &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;replay&lt;/code&gt; operators to ensure that when we re-subscribe to this &lt;code&gt;Observable&lt;/code&gt;, we&amp;rsquo;re getting the same data&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This approach may be the best we&amp;rsquo;ve seen so far. We get all the benefits of &lt;code&gt;Loader&lt;/code&gt;s and &lt;code&gt;Observable&lt;/code&gt;s, but unfortunately, we still have some boilerplate: we have to find a place outside the activity life-cycle for our &lt;code&gt;Observable&lt;/code&gt; and we have to remember to un-subscribe from that &lt;code&gt;Obsevable&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;rxlifecycle&#34;&gt;RxLifecycle&lt;/h4&gt;

&lt;p&gt;RxLifecycle can alleviate some of the weaknesses of the previous approach by giving us a way to automatically complete observable &amp;ldquo;sequences based on Activity or Fragment life-cycle events.&amp;rdquo;&lt;sup&gt;1&lt;/sup&gt; There&amp;rsquo;s not much boilerplate we have to write to take advantage of this, which is an impressive feat of the library:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;MyActivity&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;extends&lt;/span&gt; RxActivity &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #AA22FF&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;onResume&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;super&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;onResume&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;();&lt;/span&gt;
        myObservable
            &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;compose&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;bindToLifecycle&lt;span style=&#34;color: #666666&#34;&gt;())&lt;/span&gt;
            &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;subscribe&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Unfortunately, if we don&amp;rsquo;t want to subclass a particular kind of Activity to take advantage of this we&amp;rsquo;ll need to write more boilerplate to generate an observable sequence of life-cycle events. Either way, RxLifecycle, combined with the previously outlined cache-replay approach, gives us a pretty nice way of loading data in our Android apps.&lt;/p&gt;

&lt;h4 id=&#34;rxgroups&#34;&gt;RxGroups&lt;/h4&gt;

&lt;p&gt;As far as I know, RxGroups is the most recent entry in the long line of solutions to data loading in Android apps. RxGroups alone gives us memory-leak-free querying whose results are cached across orientation changes, and according to &lt;a href=&#34;https://github.com/airbnb/RxGroups&#34;&gt;the docs&lt;/a&gt;, the code we need to write to get this is pretty small. Since RxGroups seems to give us all of the benefits of &lt;code&gt;Loader&lt;/code&gt;s and &lt;code&gt;Observable&lt;/code&gt;s with the smallest amount of boilerplate, I think it may be the best solution out there, aside from the solution I&amp;rsquo;m about to propose.&lt;/p&gt;

&lt;h4 id=&#34;other-rxloader-libraries&#34;&gt;Other &amp;ldquo;RxLoader&amp;rdquo; Libraries&lt;/h4&gt;

&lt;p&gt;There are a at least two other libraries that leverage RxJava for data loading. Neither of these libraries, however, use Android Loaders, so they wind up reinventing much of the functionality of &lt;code&gt;Loader&lt;/code&gt;s and users of these libraries are still stuck with a few lines of boilerplate.&lt;/p&gt;

&lt;h3 id=&#34;a-better-way&#34;&gt;A Better Way?&lt;/h3&gt;

&lt;p&gt;I think if we use &lt;code&gt;Loader&lt;/code&gt;s &lt;em&gt;with&lt;/em&gt; &lt;code&gt;Observable&lt;/code&gt;s, we can come up with a solution that&amp;rsquo;s better than the above solutions. Here&amp;rsquo;s the basic idea: we wrap the call to &lt;code&gt;LoaderManager.initLoader&lt;/code&gt; in an &lt;code&gt;Observable&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;Observable&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;create&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; Observable&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;OnSubscribe&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #AA22FF&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;call&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;final&lt;/span&gt; Subscriber&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;?&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;super&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; subscriber&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
        loaderManager&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;initLoader&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;loaderId&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt;
                &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; LoaderManager&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;LoaderCallbacks&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color: #AA22FF&#34;&gt;@Override&lt;/span&gt;
                    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; Loader&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;onCreateLoader&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; id&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt; Bundle args&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
                        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// return some loader&lt;/span&gt;
                    &lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;

                    &lt;span style=&#34;color: #AA22FF&#34;&gt;@Override&lt;/span&gt;
                    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;onLoadFinished&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;Loader&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; loader&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt; T data&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
                        subscriber&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;data&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;
                    &lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;

                    &lt;span style=&#34;color: #AA22FF&#34;&gt;@Override&lt;/span&gt;
                    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;onLoaderReset&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;Loader&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; loader&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{}&lt;/span&gt;
            &lt;span style=&#34;color: #666666&#34;&gt;});&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;        
&lt;span style=&#34;color: #666666&#34;&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To be sure, this isn&amp;rsquo;t the cleanest way of doing this, but I think its a useful way of initially presenting the idea. Let&amp;rsquo;s think for a second about what this simple little trick gives us.&lt;/p&gt;

&lt;p&gt;First, we don&amp;rsquo;t have to worry about un-subscribing from this &lt;code&gt;Observable&lt;/code&gt; to avoid memory leaks because the &lt;code&gt;Observable&lt;/code&gt; &lt;em&gt;won&amp;rsquo;t survive the configuration change.&lt;/em&gt; Moreover, although the Observable gets garbage collected upon an orientation change, the data it emits will persist across orientation changes because that data is loaded with a &lt;code&gt;Loader.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;These two properties let us write boilerplate-free data loading code like the code with which we began this article:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BoilerplateFree&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;extends&lt;/span&gt; AppCompatActivity &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...    &lt;/span&gt;

    &lt;span style=&#34;color: #AA22FF&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;onCreate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;Bundle savedInstanceState&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;super&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;onCreate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;savedInstanceState&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;
        setContentView&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;R&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;layout&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;activity_boilerplate_free&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;
        mLoginObservable&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;subscribe&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; Action1&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;AuthManager&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;AuthResponse&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color: #AA22FF&#34;&gt;@Override&lt;/span&gt;
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;call&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;AuthManager&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;AuthResponse&lt;/span&gt; authResponse&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
                Log&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;d&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;TAG&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;call: Successfully logged in&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;                
            &lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color: #666666&#34;&gt;});&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But where does the &lt;code&gt;mLoginObservable&lt;/code&gt; that&amp;rsquo;s wrapped the &lt;code&gt;LoaderManager.init&lt;/code&gt; call come from? That&amp;rsquo;s where RxLoader comes into play. RxLoader is a &lt;em&gt;very&lt;/em&gt; lightweight library (less than 150 LOC). It&amp;rsquo;s simply an RxJava &lt;code&gt;Transformer&lt;/code&gt; that lets you take an Observable and compose it into something with loader-like behaviour, something that in fact uses a &lt;code&gt;Loader&lt;/code&gt; to get this behaviour for free. With RxLoader, your data loading code is as simple as this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BoilerplateFree&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;extends&lt;/span&gt; AppCompatActivity &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...    &lt;/span&gt;

    &lt;span style=&#34;color: #AA22FF&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;onCreate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;Bundle savedInstanceState&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;super&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;onCreate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;savedInstanceState&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;
        setContentView&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;R&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;layout&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;activity_boilerplate_free&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;background-color: #ffffcc&#34;&gt;        mLoginObservable&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;compose&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;RxLoader&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;from&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;            &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;subscribe&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; Action1&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;AuthManager&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;AuthResponse&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color: #AA22FF&#34;&gt;@Override&lt;/span&gt;
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;call&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;AuthManager&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;AuthResponse&lt;/span&gt; authResponse&lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;{&lt;/span&gt;
                Log&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #7D9029&#34;&gt;d&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt;TAG&lt;span style=&#34;color: #666666&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;call: Successfully logged in&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;);&lt;/span&gt;                
            &lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color: #666666&#34;&gt;});&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #666666&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;One line of code gets you an &lt;code&gt;Observable&lt;/code&gt; with memory-leak-proof data loading whose results are cached across orientation changes.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kmdupr33/RxLoader&#34;&gt;Here&amp;rsquo;s&lt;/a&gt; the project on github. I&amp;rsquo;ll be improving it and getting it on to maven central soon.&lt;/p&gt;

&lt;h3 id=&#34;notes&#34;&gt;Notes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Quote is from &lt;a href=&#34;https://github.com/trello/RxLifecycle&#34;&gt;the RxLifecycle docs&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Introduction to RxJava for Android (Pt. 2)</title>
      <link>http://philosophicalhacker.com/2015/06/19/introduction-to-rxjava-for-android-pt-2/</link>
      <pubDate>Fri, 19 Jun 2015 12:19:14 +0000</pubDate>
      
      <guid>http://philosophicalhacker.com/2015/06/19/introduction-to-rxjava-for-android-pt-2/</guid>
      <description>&lt;p&gt;I concluded my last post by summing up what we&amp;rsquo;ve seen so far and what we still need to understand about RxJava:&lt;/p&gt;

&lt;blockquote&gt;We now know what an asynchronous data stream is and we know that RxJava uses the Observer pattern to deliver these streams to everyone that’s interested. We still don’t know, however, what it means for a data stream to be “functionally transformed” nor do we know how RxJava allows us to represent anything as an asynchronous data stream that can be created and consumed on any thread. These are questions I’ll have to tackle in the second part of this written version of my upcoming RxJava talk.&lt;/blockquote&gt;

&lt;p&gt;In this post, I&amp;rsquo;ll fill in the missing gaps in our understanding of my initial statement of what RxJava allows us to do.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Recall that that initial statement was this:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_rxjava_def.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_rxjava_def-1024x791.jpg&#34; alt=&#34;rxjava_prezi_rxjava_def&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Recall that a data-stream, as I&amp;rsquo;ve defined it, is just sequential data that has a well-defined termination point and a way of notifying processors of that data that an error has occurred. RxJava lets us create asynchronous data streams out of anything. This might sound confusing until we remember that we are already familiar with a pattern that allows us to make synchronous data streams out of anything: the iterator pattern.&lt;/p&gt;

&lt;p&gt;The definition for an &lt;code&gt;Iterator&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_as_async_iterator.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_as_async_iterator-1024x791.jpg&#34; alt=&#34;rxjava_as_async_iterator&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Notice that an Iterator fits the definition of a data-stream. Its ordered data that can be processed by calling &lt;code&gt;next()&lt;/code&gt;. It has a well-defined stopping point: when &lt;code&gt;hasNext()&lt;/code&gt; returns false. Finally, processors of an iterator&amp;rsquo;s data can also be notified if there was an error processing the data: the iterator can simply throw an exception.&lt;/p&gt;

&lt;p&gt;You can make any class iterable as long as that class can supply an iterator with which to traverse its elements. This makes it possible to turn any class into a synchronous data stream. This is actually how the &lt;a href=&#34;https://docs.oracle.com/javase/1.5.0/docs/guide/language/foreach.html&#34;&gt;for-each syntax works in java&lt;/a&gt;. All Collection classes can return an iterator that&amp;rsquo;s used to sequentially traverse the data they contain.&lt;/p&gt;

&lt;p&gt;This shouldn&amp;rsquo;t be surprising since the motivation for the iterator pattern according to the Gang of Four is to:&lt;/p&gt;

&lt;blockquote&gt;Provide a way to access elements of an aggregate object sequentially without exposing its underlying implementation.

-GoF, Design Patterns&lt;/blockquote&gt;

&lt;p&gt;RxJava Observables can be created out of anything and remember that Observables are just asynchronous data streams. Because Observables are asynchronous data streams that can be created out of anything just as Iterators are synchronous datastreams that can be created out of (nearly) anything, the &lt;a href=&#34;http://reactivex.io/intro.html&#34;&gt;reactive x introduction refers&lt;/a&gt; to Observables as the &amp;ldquo;asynchronous/push dual to the synchronous/pull iterator.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;This will make more sense once we see what it looks like to create an Observable:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_obserable_creation.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_obserable_creation-1024x791.jpg&#34; alt=&#34;rxjava_obserable_creation&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here we&amp;rsquo;re creating an Observable that emits the data from a long-running operation performed by &lt;code&gt;userFetcher.fetchUsers()&lt;/code&gt;. Once &lt;code&gt;fetchUsers()&lt;/code&gt; returns with the Users, we call &lt;code&gt;onNext()&lt;/code&gt; on the &lt;code&gt;Subscriber&lt;/code&gt; that&amp;rsquo;s passed in to &lt;code&gt;call()&lt;/code&gt; method. Recall that a Subscriber is just a consumer of asynchronous data, so by calling &lt;code&gt;onNext()&lt;/code&gt;, we are passing the users we&amp;rsquo;ve fetched to the &lt;code&gt;Subscriber&lt;/code&gt;. This call to &lt;code&gt;onNext()&lt;/code&gt; as the asynchronous analog to the iterator&amp;rsquo;s &lt;code&gt;next()&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll notice that there&amp;rsquo;s another call after &lt;code&gt;onNext()&lt;/code&gt;: its the &lt;code&gt;onComplete()&lt;/code&gt; call. This tells the &lt;code&gt;Subscriber&lt;/code&gt;s that the asynchronous data stream has reached its end. This call is the asynchronous analogue of the iterator&amp;rsquo;s &lt;code&gt;hasNext()&lt;/code&gt; method returning false.&lt;/p&gt;

&lt;p&gt;Finally, note that if there&amp;rsquo;s an exception thrown by the method that fetches the users, we call &lt;code&gt;onError()&lt;/code&gt;. This, of course, is the asynchronous analog of the iterator throwing an exception while processing synchronous data.&lt;/p&gt;

&lt;p&gt;Alright, so hopefully at this point, we know what this means:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/we_know_rxjava_is_observer_plus_iterator.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/we_know_rxjava_is_observer_plus_iterator-1024x791.jpg&#34; alt=&#34;we_know_rxjava_is_observer_plus_iterator&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But we still don&amp;rsquo;t know this:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/still_dont_know_functional.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/still_dont_know_functional-1024x791.jpg&#34; alt=&#34;still_dont_know_functional&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When I say &amp;ldquo;functional transformation,&amp;rdquo; I&amp;rsquo;m using &amp;ldquo;functional&amp;rdquo; in the same sense that its used when people talk about functional programming. Functional transformations are transformations of data that don&amp;rsquo;t rely on any data outside of the function that does the transformation and that don&amp;rsquo;t have any side effects. We perform transformations of data all the time, but those transformations might not count as functional.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve ever written a filter for an list adapter, you&amp;rsquo;ve probably had to do a transformation of the unfiltered data. Here&amp;rsquo;s what this looks like in the Android Source&amp;rsquo;s implementation of filtering for the &lt;code&gt;ArrayAdapter&lt;/code&gt; class:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/functional_transformations_are_not_new.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/functional_transformations_are_not_new-e1434712869664-1024x792.jpg&#34; alt=&#34;functional_transformations_are_not_new&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This transformation, however, is not entirely functional. Its true that this method is creating a new Array to hold the filtered values rather than modifying the array of original values. This makes performFiltering() semi-functional since it doesn&amp;rsquo;t modify data outside of the method. However, because this method relies on data from outside of the function, it fails to be an entirely functional transformation of the unfiltered values.&lt;/p&gt;

&lt;p&gt;RxJava, on the other hand, does perform completely functional transformations of asynchronous data. Here&amp;rsquo;s what that looks like:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/functional_transformations_are_not_new-e1434712869664.jpg&#34;&gt;
&lt;/a&gt; &lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_full_on_functional_real.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_full_on_functional_real-e1434713514839-1024x300.jpg&#34; alt=&#34;rxjava_full_on_functional_real&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here we&amp;rsquo;re creating an &lt;code&gt;Observable&lt;/code&gt; out of an array. We then transform the data stream emitted by this &lt;code&gt;Observable&lt;/code&gt; by calling &lt;code&gt;filter()&lt;/code&gt; on the Observable created from the array. &lt;code&gt;filter()&lt;/code&gt; takes a function that returns whether the items emitted by the source &lt;code&gt;Observable&lt;/code&gt; should be included in the transformed data-stream. In this case, the function passed into &lt;code&gt;filter()&lt;/code&gt; will return true for &amp;ldquo;Going Global with Google Play&amp;rdquo; and false for &amp;ldquo;Keynote,&amp;rdquo; so the former and not the latter will be emitted by the &lt;code&gt;Observable&lt;/code&gt; returned by &lt;code&gt;filter()&lt;/code&gt; and consumed by the &lt;code&gt;Subscriber&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The filter call is a functional transformation because the original Observable that was created from the array is not modified and because the &lt;code&gt;Func1&lt;/code&gt; that performs the filtering operation does not operate on any data that exists outside of &lt;code&gt;Func1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;These functional transformations are called &amp;ldquo;operators&amp;rdquo;, and their functional nature is what allows us to chain together multiple operators to shape the asynchronous data stream so that it can be conveniently consumed by a &lt;code&gt;Subscriber&lt;/code&gt;. We&amp;rsquo;ll see what this chaining looks like later.&lt;/p&gt;

&lt;p&gt;At this point, if I&amp;rsquo;ve done my job right, you should know that this means:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/know_observable_subscriber_operators.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/know_observable_subscriber_operators-1024x791.jpg&#34; alt=&#34;know_observable_subscriber_operators&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We still don&amp;rsquo;t know, however, how RxJava let&amp;rsquo;s us create and consume asynchronous data streams on any thread. This is accomplished through &lt;code&gt;Schedulers&lt;/code&gt; and this is how &lt;code&gt;Schedulers&lt;/code&gt; are applied to &lt;code&gt;Observables&lt;/code&gt; and &lt;code&gt;Subscribers&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/schedulers.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/schedulers-e1434714320163-1024x443.jpg&#34; alt=&#34;schedulers&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The key lines here are the &lt;code&gt;subscribeOn()&lt;/code&gt; and &lt;code&gt;observeOn()&lt;/code&gt; lines. These lines take &lt;code&gt;Schedulers&lt;/code&gt; that determine the threads on which asynchronous data is created and consumed, respectively. We pass a &lt;code&gt;Scheduler&lt;/code&gt; to &lt;code&gt;subscribeOn()&lt;/code&gt; that schedules the asynchronous data to be created on a background io thread and we pass a &lt;code&gt;Scheduler&lt;/code&gt; to the &lt;code&gt;observeOn()&lt;/code&gt; method that ensures that the asynchronous data is consumed on the main thread.&lt;/p&gt;

&lt;p&gt;One quick thing to note here is that the &lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt; method is not actually a part of RxJava. Its a part of &lt;a href=&#34;https://github.com/ReactiveX/RxAndroid&#34;&gt;RxAndroid&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;At this point, you should be in a pretty good position to understand all of my initial statement of what RxJava does:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/we_know_it_all1.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/we_know_it_all1-1024x791.jpg&#34; alt=&#34;we_know_it_all&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And now that you understand what RxJava is, you can understand how its able to make quick work of a task like the one I described in &lt;a href=&#34;http://www.philosophicalhacker.com/2015/06/12/an-introduction-to-rxjava-for-android/&#34;&gt;the first post in this series&lt;/a&gt;. Recall that the task was to execute a query from a &lt;code&gt;SearchView&lt;/code&gt; within an &lt;code&gt;Actionbar&lt;/code&gt; only if that query consisted of three characters and only if there was at least a 100 millisecond delay before any additional characters were typed into the SearchView.&lt;/p&gt;

&lt;p&gt;This functionality exists already in Google&amp;rsquo;s iosched app. Here is a reimplementation of that functionality using RxJava:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/teaser_solution.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/teaser_solution-e1434715009899-1024x717.jpg&#34; alt=&#34;teaser_solution&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m only going to explain parts of this snippet, but if you want to check out the full source, you can do that &lt;a href=&#34;https://github.com/kmdupr33/iosched/tree/feature/rxjava_rewrite&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Note that there are several operators here that I didn&amp;rsquo;t mention before, namely, &lt;code&gt;debouce()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt;. RxJava has &lt;a href=&#34;https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators&#34;&gt;a ton of operators&lt;/a&gt;, so be sure to check them all out. The &lt;code&gt;debounce()&lt;/code&gt; operator is what allows us to only execute a search on a query only if there&amp;rsquo;s been a 100 millisecond delay after the last text change in the query string.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;filter()&lt;/code&gt; operator here is only used to make sure that there is a fragment available to display the data fetched from the search, but we could have easily added another &lt;code&gt;filter()&lt;/code&gt; operator that would check the length of the query string.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;map()&lt;/code&gt; operators transform the data emitted by their source &lt;code&gt;Observable&lt;/code&gt;. The first &lt;code&gt;map()&lt;/code&gt; operator converts the query string into an intent created from that query string. The second &lt;code&gt;map()&lt;/code&gt; operator converts that intent into a &lt;code&gt;Bundle&lt;/code&gt; that can be used by the &lt;code&gt;SessionsFragment&lt;/code&gt; to load the appropriate sessions (based on the original query string).&lt;/p&gt;

&lt;p&gt;If I&amp;rsquo;ve done my job right, hopefully now you know what RxJava is and why its awesome! Feel free to point out anything that was unclear or inaccurate.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introduction to RxJava for Android: The Talk</title>
      <link>http://philosophicalhacker.com/2015/06/16/introduction-to-rxjava-for-android-the-talk/</link>
      <pubDate>Wed, 17 Jun 2015 01:48:45 +0000</pubDate>
      
      <guid>http://philosophicalhacker.com/2015/06/16/introduction-to-rxjava-for-android-the-talk/</guid>
      <description>&lt;p&gt;Earlier today, I gave my Intro To RxJava talk. I&amp;rsquo;m not thrilled at how clear I was at explaining certain aspects of RxJava, but here&amp;rsquo;s the video nonetheless. My talk starts at 28:32. Hopefully, I&amp;rsquo;ll do a better job when I finish &lt;a href=&#34;http://www.philosophicalhacker.com/2015/06/12/an-introduction-to-rxjava-for-android/&#34;&gt;the written version of this talk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you want to hear a hilarious take down of the design of the new Pizza Hut app, check out &lt;a href=&#34;https://www.linkedin.com/profile/view?id=51923912&amp;amp;trk=hp-feed-member-name&#34;&gt;Ian&amp;rsquo;s&lt;/a&gt; talk that happens before mine.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://prezi.com/xby6mpyb_4uo/?utm_campaign=share&amp;amp;utm_medium=copy&#34;&gt;Here&lt;/a&gt; are the slides that I used.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kmdupr33/iosched/tree/feature/rxjava_rewrite&#34;&gt;Here&amp;rsquo;s&lt;/a&gt; the source for the rxjava rewrite of the session search functionality. I&amp;rsquo;m particularly interested in what experienced RxJava-ers think of how I created an Observable from the SearchActivity&amp;rsquo;s search widget text listener.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An Introduction to RxJava for Android (Pt. 1)</title>
      <link>http://philosophicalhacker.com/2015/06/12/an-introduction-to-rxjava-for-android/</link>
      <pubDate>Fri, 12 Jun 2015 12:34:53 +0000</pubDate>
      
      <guid>http://philosophicalhacker.com/2015/06/12/an-introduction-to-rxjava-for-android/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m taking a brief break from talking about testing. I&amp;rsquo;ll resume my discussion of how &lt;a href=&#34;http://www.philosophicalhacker.com/2015/05/31/towards-a-unit-testable-fork-of-googles-iosched-app/&#34;&gt;I&amp;rsquo;m making Google&amp;rsquo;s IOSched app unit testable&lt;/a&gt; after I&amp;rsquo;ve posted the content from &lt;a href=&#34;http://www.meetup.com/University-Android/events/222048562/&#34;&gt;my upcoming talk on RxJava&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt; &lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_rxjava_def.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_rxjava_def-1024x791.jpg&#34; alt=&#34;rxjava_prezi_rxjava_def&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;RxJava is a library that let&amp;rsquo;s you represent anything as an asynchronous data-stream that can be created on any thread, functionally transformed, and consumed by everyone on any thread.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_outline_talk.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_outline_talk-1024x791.jpg&#34; alt=&#34;rxjava_prezi_outline_talk&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t expect that definition to mean much to you at this point, but don&amp;rsquo;t worry. During this presentation, we&amp;rsquo;re going to break down each piece of the statement I just made, and by the time we&amp;rsquo;re through, you&amp;rsquo;ll understand what RxJava is and why its awesome.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_teaser.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_teaser-1024x791.jpg&#34; alt=&#34;rxjava_prezi_teaser&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Before we start trying to understand what RxJava is, let me give you a small teaser that will give you some idea of what RxJava can do. This screenshot is from Google&amp;rsquo;s IOSched app. On this screen, you can search through the various IO sessions. Whenever users type in text into the the &lt;code&gt;SearchWidget&lt;/code&gt; in the &lt;code&gt;Actionbar&lt;/code&gt;, the database is re-queried using the entered text and the results are displayed in a list below the &lt;code&gt;Actionbar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, suppose that you&amp;rsquo;re supposed to implement something like this for an app you&amp;rsquo;re building, but suppose that there are some further requirements, namely, that the query should only execute if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;there are at least three characters entered into the &lt;code&gt;SearchWidget&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;there has been at least a 100 millisecond delay before any other characters have been entered into the &lt;code&gt;SearchWidget&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How many lines of code do you think it would take to implement something like this? If you look at the &lt;a href=&#34;https://github.com/kmdupr33/iosched/blob/master/android/src/main/java/com/google/samples/apps/iosched/ui/SearchActivity.java&#34;&gt;IOSched source code&lt;/a&gt;, you&amp;rsquo;ll get an idea of what it would take. If you followed the strategy in the IOSched app, you&amp;rsquo;d probably set a listener on the &lt;code&gt;SearchWidget&lt;/code&gt; text and use an if-statement to check to see if the text is at least three characters long. If it is, you&amp;rsquo;d call a method that uses a &lt;code&gt;Handler&lt;/code&gt; to remove any messages that have been scheduled to execute in the last 100 milliseconds and that schedules a new message to be sent at the end of a 100 millisecond delay.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what&amp;rsquo;s awesome about RxJava: Once you have an RxJava &lt;code&gt;Observable&lt;/code&gt; that&amp;rsquo;s set up to report events about text changes in the SearchWidget, you can do the equivalent of all of this in three lines of code. The RxJava way of doing this, moreover, will provide you with more flexibility that will help you cope with any subsequent changes you&amp;rsquo;ll need to make to this portion of the code.&lt;/p&gt;

&lt;p&gt;Hopefully, that&amp;rsquo;s enough to keep you interested in learning about RxJava in case I&amp;rsquo;ve failed to make my introduction to it easy to understand.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_async_data.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_async_data-1024x791.jpg&#34; alt=&#34;rxjava_prezi_async_data&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with something that&amp;rsquo;s familiar. RxJava let&amp;rsquo;s you deliver asynchronous data to anyone who&amp;rsquo;s interested in receiving it. Of course, RxJava does more than that, but, this is definitely something that you can do with RxJava. This is something that you do all the time without RxJava. Here&amp;rsquo;s a snippet that shows how how changes in the search query string for an IO session are delivered to a &lt;code&gt;OnQueryTextListener&lt;/code&gt;, a consumer of asynchronous data.&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_async_data_code.jpg&#34;&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_async_data_code1.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_async_data_code1-1024x791.jpg&#34; alt=&#34;rxjava_prezi_async_data_code&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what this would look like with RxJava:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_async_data_rxjava_code.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_async_data_rxjava_code-1024x791.jpg&#34; alt=&#34;rxjava_prezi_async_data_rxjava_code&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In this snippet, we have an &lt;code&gt;Observable&lt;/code&gt; that represents the data stream produced by changes in the text of the &lt;code&gt;SearchWidget&lt;/code&gt;. We also have a &lt;code&gt;Subscriber&lt;/code&gt; (created from the &lt;code&gt;Action1&lt;/code&gt; passed into the &lt;code&gt;subscribe()&lt;/code&gt; method) who&amp;rsquo;s interested in any changes in the text of the &lt;code&gt;SearchWidget&lt;/code&gt;. Let&amp;rsquo;s get a little clearer on the definitions of &lt;code&gt;Observable&lt;/code&gt;s and &lt;code&gt;Subscriber&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_define_observer_subscriber.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_define_observer_subscriber-1024x791.jpg&#34; alt=&#34;rxjava_prezi_define_observer_subscriber&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Notice that an &lt;code&gt;Observable&lt;/code&gt; represents a &lt;em&gt;data stream&lt;/em&gt; and that there can be &lt;em&gt;multiple Subscribers&lt;/em&gt; who are interested in consuming this asynchronous data stream. I&amp;rsquo;ll say more about what I mean by the phrase &amp;ldquo;data stream&amp;rdquo; later. For now, let&amp;rsquo;s focus on the fact that RxJava let&amp;rsquo;s multiple &lt;code&gt;Subscribers&lt;/code&gt; consume asynchronous data.&lt;/p&gt;

&lt;p&gt;By itself, this fact isn&amp;rsquo;t really a big deal. Its basically just the observer pattern. You work with objects that leverage the observer pattern to deliver asynchronous data to multiple recipients all the time. Anytime you call &lt;code&gt;RecyclerView.Adapter.notifyDatasetChanged()&lt;/code&gt; (or the &lt;code&gt;ListView&lt;/code&gt; equivalent), you&amp;rsquo;re taking advantage of the observer pattern.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;RecyclerView&lt;/code&gt; is an observer of any changes to the &lt;code&gt;Adapter&lt;/code&gt;&amp;rsquo;s data, but you could have more than one observer. Any object that wants to be an observer of the &lt;code&gt;Adapter&lt;/code&gt;&amp;rsquo;s data would just have to call &lt;code&gt;registerDatasetObserver()&lt;/code&gt; just like the &lt;code&gt;RecyclerView&lt;/code&gt; does.&lt;/p&gt;

&lt;p&gt;If you want to use RxJava to deliver asynchronous data to multiple &lt;code&gt;Subscribers&lt;/code&gt; here&amp;rsquo;s what that might look like:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/Screen-Shot-2015-06-12-at-7.18.56-AM.png&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/Screen-Shot-2015-06-12-at-7.18.56-AM-e1434108030545-1024x397.png&#34; alt=&#34;Screen Shot 2015-06-12 at 7.18.56 AM&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ignore the &lt;code&gt;publish()&lt;/code&gt; and &lt;code&gt;connect()&lt;/code&gt; method calls for a moment. We&amp;rsquo;ll talk about those later. The important thing here is that there are multiple &lt;code&gt;Subscribers&lt;/code&gt; set up to be notified of any changes in the &lt;code&gt;SearchWidget&lt;/code&gt;&amp;rsquo;s query string text. (By the way, if you&amp;rsquo;re not familiar with &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax&#34;&gt;lambda expressions&lt;/a&gt;, you should probably get familiar before continuing.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/?attachment_id=440&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/RxJavaTalk-02-e1434108825723-300x72.png&#34; alt=&#34;RxJavaTalk-02&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alright, so we&amp;rsquo;ve just established that RxJava let&amp;rsquo;s you deliver asynchronous data to everyone who&amp;rsquo;s interested. The data delivered to &lt;code&gt;Subscriber&lt;/code&gt;&amp;rsquo;s, however, has a specific structure. &amp;rdquo;Data stream&amp;rdquo; is the phrase that I&amp;rsquo;ve been using to refer to that specific structure. We&amp;rsquo;re now in a position to see precisely what I&amp;rsquo;ve meant by this phrase.&lt;/p&gt;

&lt;p&gt;A data stream, as Im defining it, is just ordered data that has a well-defined stopping point and a way of notifying processors of the data that an error has occurred.  Java&amp;rsquo;s &lt;code&gt;Reader&lt;/code&gt; would count as a data stream in the sense that I&amp;rsquo;m defining it here because its &lt;code&gt;read()&lt;/code&gt; method returns -1 once its reached the end of a byte[] and because it throws exceptions if there&amp;rsquo;s an error with processing the data.&lt;/p&gt;

&lt;p&gt;I admit that this is might be an unnatural definition of the phrase &amp;rdquo;data stream,&amp;rdquo; but my primary goal here is to have a succinct phrase for referring to the structured data delivered by Observables rather than to come up with a definition for the phrase &amp;ldquo;data stream&amp;rdquo; that fits our ordinary usage, so don&amp;rsquo;t get philosophical on me. Just know that when I say &amp;ldquo;data stream,&amp;rdquo; I mean an ordered data that has a well-defined stopping point and a way of notifying processors of the data that an error has occurred.&lt;/p&gt;

&lt;p&gt;The fact that RxJava deals with data streams rather than just data is reflected in their use of marble diagrams to represent Observables. I&amp;rsquo;ve been using these diagrams throughout the presentation. Let me briefly explain them:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/RxJavaTalk_as-a-data-stream.png&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/RxJavaTalk_as-a-data-stream-300x58.png&#34; alt=&#34;RxJavaTalk_as a data stream&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Each circle along this line represents a piece of data emitted by an Observable. The arrow at the end of the line represents the fact that the data is ordered. The solid line following the word &amp;ldquo;stream&amp;rdquo; indicates that the Observable stream has successfully emitted all of its items. An &amp;ldquo;X&amp;rdquo; at any point along the line, however, indicates that an error has occurred while attempting to emit the asynchronous data:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/RxJavaTalk_wtf-is-he-saying.png&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/RxJavaTalk_wtf-is-he-saying-300x58.png&#34; alt=&#34;RxJavaTalk_wtf is he saying&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You saw this digram earlier. Its was a (bad) joke that represented your stream of consciousness as an Observable sequence that&amp;rsquo;s experienced an error because your mind was just blown by my initial summary of RxJava. Terrible jokes aside, that&amp;rsquo;s how you represent errors on a marble diagram.&lt;/p&gt;

&lt;p&gt;Technically, these marble diagrams could represent synchronous data streams, but RxJava is really all about &lt;em&gt;asynchronous&lt;/em&gt; data streams. Asynchronous data streams are just data streams that are processed by consumers who aren&amp;rsquo;t going to just wait around for all of the data to be available. Consumers of a synchronous data stream say, &amp;ldquo;I&amp;rsquo;m not going anywhere until you give me that data!&amp;rdquo; Consumers of asynchronous data say, &amp;ldquo;Fetching the data sounds like it could take a while. I&amp;rsquo;m going to go about my day. Why don&amp;rsquo;t you notify me when you get that data for me.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s recap. We started off with this statement of what RxJava does:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_rxjava_def.jpg&#34;&gt;&lt;img src=&#34;http://www.philosophicalhacker.com/wp-content/uploads/2015/06/rxjava_prezi_rxjava_def-1024x791.jpg&#34; alt=&#34;rxjava_prezi_rxjava_def&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We now know what an asynchronous data stream is and we know that RxJava uses the Observer pattern to deliver these streams to everyone that&amp;rsquo;s interested. We still don&amp;rsquo;t know, however, what it means for a data stream to be &amp;ldquo;functionally transformed&amp;rdquo; nor do we know how RxJava allows us to represent anything as an asynchronous data stream that can be created and consumed on any thread. These are questions I&amp;rsquo;ll have to tackle in &lt;a href=&#34;http://www.philosophicalhacker.com/2015/06/19/introduction-to-rxjava-for-android-pt-2/&#34;&gt;the second part&lt;/a&gt; of this written version of &lt;a href=&#34;http://www.philosophicalhacker.com/2015/06/16/introduction-to-rxjava-for-android-the-talk/&#34;&gt;my upcoming RxJava talk&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>How to Keep your RxJava Subscribers from Leaking</title>
      <link>http://philosophicalhacker.com/2015/03/24/how-to-keep-your-rxjava-subscribers-from-leaking/</link>
      <pubDate>Tue, 24 Mar 2015 23:56:32 +0000</pubDate>
      
      <guid>http://philosophicalhacker.com/2015/03/24/how-to-keep-your-rxjava-subscribers-from-leaking/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; Shortly after writing this, I realized that the solution that I present here isn&amp;rsquo;t very good. I&amp;rsquo;m leaving it here just in case it can serve as a building block for better solutions.&lt;/p&gt;

&lt;p&gt;Sometimes you don&amp;rsquo;t have control over the lifecycle of your &lt;code&gt;Subscribers&lt;/code&gt;. In these cases, to avoid leaking your &lt;code&gt;Subscriber&lt;/code&gt;, you have to unsubscribe from your &lt;code&gt;Observable&lt;/code&gt; when you&amp;rsquo;re notified that your &lt;code&gt;Subscriber&lt;/code&gt; is about to be destroyed. It can be really annoying to have to worry about unsubscribing your &lt;code&gt;Subscriptions&lt;/code&gt;to avoid memory leaks, so in this post, I&amp;rsquo;ll show how, with a few lines of code, you can stop worrying about leaking your &lt;code&gt;Subscribers&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Before I try to show how to memory-leak-proof your &lt;code&gt;Subscribers&lt;/code&gt;, I want to give a concrete example that shows when memory-leak-proof &lt;code&gt;Subscribers&lt;/code&gt; might be useful. This example will also clarify the problem that memory-leak-proof &lt;code&gt;Subscribers&lt;/code&gt; are trying to solve. I spend most of my time doing Android development these days, so an Android example is the most natural way for me to elaborate on this problem, so here&amp;rsquo;s an Android-specific use-case: You&amp;rsquo;d probably want want a memory-leak-proof &lt;code&gt;Subscriber&lt;/code&gt; when you&amp;rsquo;re writing an &lt;code&gt;Activity&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;An Android &lt;code&gt;Activity&lt;/code&gt; is basically a screen that you see when you&amp;rsquo;re using an Android app. The Android framework manages the lifecycle of &lt;code&gt;Activities&lt;/code&gt;. &lt;code&gt;Activities&lt;/code&gt;, moreover, are also often responsible for responding to touch events.&lt;/p&gt;

&lt;p&gt;Sometimes you want to fetch some data and then update the UI with that data in response to a touch event, and sometimes fetching data can&amp;rsquo;t be done on the main thread. &lt;code&gt;Observables&lt;/code&gt; can be a nice way to handle this problem:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/kmdupr33/ef8023275ca36d201360.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;However, if the Android framework wants to destroy your &lt;code&gt;Activity&lt;/code&gt; while your &lt;code&gt;Observable&lt;/code&gt; is doing its thing, you run into a problem: The &lt;code&gt;Observable&lt;/code&gt; will keep your Activity from being garbage collected, because your &lt;code&gt;Activity&lt;/code&gt; contains a reference to an anonymous inner &lt;code&gt;Subscriber&lt;/code&gt; and this &lt;code&gt;Subscriber&lt;/code&gt; implicitly contains a reference to your &lt;code&gt;Activity&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The straightforward solution to this is to unsubscribe from your &lt;code&gt;Observable&lt;/code&gt; when the &lt;code&gt;Activity&lt;/code&gt; is about to be destroyed:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/kmdupr33/338f863a42f53b736bdd.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Although this solution is straightforward, it puts you in an unfortunate dilemma:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Horn 1: You have to worry about unsubscribing from your &lt;code&gt;Observer&lt;/code&gt; in all of your &lt;code&gt;Activities&lt;/code&gt; in your app&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;OR&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Horn 2: You have to unsubscribe in a base &lt;code&gt;Activity&lt;/code&gt; class that calls unsubscribe on a &lt;code&gt;CompositeSubscription&lt;/code&gt;, have subclasses add &lt;code&gt;Subscriptions&lt;/code&gt; to the base &lt;code&gt;Activity&lt;/code&gt;&amp;rsquo;s &lt;code&gt;CompositeSubscription&lt;/code&gt;, and make all of your &lt;code&gt;Activities&lt;/code&gt; extend that base class.¹&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I think there might be a better solution: If we subclass &lt;code&gt;Observable&lt;/code&gt; to wrap our &lt;code&gt;Subscribers&lt;/code&gt; in a &lt;code&gt;Subscriber&lt;/code&gt; &lt;a href=&#34;http://en.wikipedia.org/wiki/Decorator_pattern&#34;&gt;decorator&lt;/a&gt; that delegates work to its weakly held, wrapped &lt;code&gt;Subscriber&lt;/code&gt;, we can keep clients from having to worry about leaking their &lt;code&gt;Subscribers&lt;/code&gt; &lt;em&gt;without forcing them to write boilerplate code.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To see how this would work, let&amp;rsquo;s start by defining the &lt;code&gt;Subscriber&lt;/code&gt; decorator:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/kmdupr33/b5fe4b2a67a3473e20c7.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Next, we define the Observable subclass that adds a &lt;code&gt;safeSubscribe()&lt;/code&gt; method to wrap the &lt;code&gt;Subscriber&lt;/code&gt; passed in:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/kmdupr33/057612a1d383cc196c9a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;And that&amp;rsquo;s it. Now, clients can subscribe to an &lt;code&gt;Observable&lt;/code&gt; without having to worry about leaking an object with a big memory footprint. Instead, only the &lt;code&gt;Subscriber&lt;/code&gt; decorator is leaked, and since the Subscriber decorator doesn&amp;rsquo;t have a big memory footprint, its not a huge deal if it sticks around until the &lt;code&gt;Observer&lt;/code&gt; is done doing its thing.&lt;/p&gt;

&lt;p&gt;I would love to hear what you all think about this approach.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Edit: &lt;/strong&gt;Conversation with jackhexen on the Reddit machine has made me realize that this solution is not as clean as I&amp;rsquo;ve presented it here. Activities won&amp;rsquo;t maintain strong references to their anonymous inner classes unless you store those classes in an instance variable, so technically, you&amp;rsquo;d have to store your &lt;code&gt;Subscribers&lt;/code&gt; in instance variables to prevent them for being garbage collected. This makes the solution presented here seem significantly less appealing because I was hoping to offer a solution that kept clients from having to worry about memory management. This solution clearly doesn&amp;rsquo;t do that.&lt;/p&gt;

&lt;p&gt;Notes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;This solution is discussed in &lt;a href=&#34;http://blog.danlew.net/2014/10/08/grokking-rxjava-part-4/&#34;&gt;the 4th part of Dan Lew&amp;rsquo;s helpful introduction to RxJava for Android&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>