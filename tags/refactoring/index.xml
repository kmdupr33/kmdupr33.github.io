<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>refactoring on Philosophical Hacker</title>
    <link>/tags/refactoring/</link>
    <description>Recent content in refactoring on Philosophical Hacker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 09 May 2020 14:14:58 -0400</lastBuildDate>
    
        <atom:link href="https://www.philosophicalhacker.com/tags/refactoring/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Are Source File Diffs Serially Correlated?</title>
      <link>https://www.philosophicalhacker.com/post/are-source-file-diffs-serially-correlated/</link>
      <pubDate>Sat, 09 May 2020 14:14:58 -0400</pubDate>
      
      <guid>https://www.philosophicalhacker.com/post/are-source-file-diffs-serially-correlated/</guid>
      <description>When programming, always follow the camping rule: Always leave the code base healthier than when you found it.
&amp;mdash; Martin Fowler, Refactoring
  The Boy Scouts of America have a simple rule that we can apply to our profession. Leave the campground cleaner than you found it.
&amp;mdash; Robert Martin, Clean Code
 Many of us share the attitude expressed by the above Fowler and Martin quotes. The attitude presumes that code we&amp;rsquo;re working on now will change again soon, and we&amp;rsquo;ll reap the benefits of a refactor when that happens.</description>
      
    </item>
    
    <item>
      <title>Why and How we Should Calculate Expected Utility of Refactorings</title>
      <link>https://www.philosophicalhacker.com/post/calculing-expected-utility-for-a-refactor/</link>
      <pubDate>Wed, 29 Apr 2020 08:42:51 -0400</pubDate>
      
      <guid>https://www.philosophicalhacker.com/post/calculing-expected-utility-for-a-refactor/</guid>
      <description>In my experience, most applications are a mess&amp;hellip;Changes are commonly made under urgent time pressure, which drives applications towards disorder&amp;hellip;Velocity gradually slows, and everyone comes to hate the application, their job, and their life.
&amp;mdash;Sandi Metz, &amp;ldquo;The Half-Life of Code&amp;rdquo;
 Why Many of us work in codebases that are not easy to work with, codebases that we want to make better. The way that we typically choose what parts of the codebase get made better, however, is sub-optimal.</description>
      
    </item>
    
    <item>
      <title>How to Safely move Logic out of Activities</title>
      <link>https://www.philosophicalhacker.com/post/how-to-safely-move-logic-out-of-activities/</link>
      <pubDate>Thu, 16 Jun 2016 16:58:30 -0400</pubDate>
      
      <guid>https://www.philosophicalhacker.com/post/how-to-safely-move-logic-out-of-activities/</guid>
      <description>In my last post, I argued that we should stop putting our app logic in Activitys and Fragments because it makes both unit testing and functional testing our apps more difficult. In this post, I&amp;rsquo;ll try to suggest a method of safely removing app logic from our Activitys and Fragments, drawing on a central idea discussed in Michael Feathers&amp;rsquo; Working Effectively with Legacy Code: characterization tests.
In the first section, I briefly introduce the idea of characterization tests.</description>
      
    </item>
    
  </channel>
</rss>
