<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Philosophical Hacker</title>
    <link>http://philosophicalhacker.com/tags/sicp/index.xml</link>
    <description>Recent content on Philosophical Hacker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://philosophicalhacker.com/tags/sicp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Sicp 1.1.1-1.1.7</title>
      <link>http://philosophicalhacker.com/post/sicp-111-117/</link>
      <pubDate>Tue, 29 Mar 2016 18:02:27 -0400</pubDate>
      
      <guid>http://philosophicalhacker.com/post/sicp-111-117/</guid>
      <description>

&lt;p&gt;Today was my first work day at &lt;a href=&#34;recurse.com&#34;&gt;the Recurse Center&lt;/a&gt;. Yesterday, I found out that there&amp;rsquo;s an &lt;a href=&#34;https://mitpress.mit.edu/sicp/full-text/book/book.html&#34;&gt;SICP&lt;/a&gt; study group. I&amp;rsquo;ve been wanting to study SICP for a while now, so naturally I joined. What follows are my thoughts and key take-aways from sections 1.1.1-1.1.7.&lt;/p&gt;

&lt;h1 id=&#34;declarative-vs-procedural-knowledge&#34;&gt;Declarative vs. Procedural Knowledge&lt;/h1&gt;

&lt;p&gt;Abelson et al. open the book with a really interesting distinction between declarative and procedural knowledge. Moreover, they suggest that the most significant achievement of computer science is that it provides a way for us to study procedural knowledge.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;hellip;‘‘computer science’’ is not a science and&amp;hellip;its significance has little to do with computers. The computer revolution is a revolution in the way we think and in the way we express what we think. The essence of this change is the emergence of what might best be called procedural epistemology &amp;ndash; the study of the structure of knowledge from an imperative point of view, as opposed to the more declarative point of view taken by classical mathematical subjects. Mathematics provides a framework for dealing precisely with notions of ‘‘what is.’’ Computation provides a framework for dealing precisely with notions of ‘‘how to.’’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This distinction comes out more clearly in section 1.1.7 when they emphasize the difference between a procedure in scheme and a mathematical function. This difference is brought out with an example function definition for the square root:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;sqrt (x) = the y such that y &amp;gt;= 0 and y^2=x&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Although this is a perfectly valid function definition for mathematics, it tells us nothing about how to define a procedure that will return the square root of x. After pointing this out, the authors connect the difference between procedures and functions with their distinction between procedural and declarative knowledge:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The contrast between function and procedure is a reflection of the general distinction between describing properties of things and describing how to do things, or, as it is sometimes referred to, the distinction between declarative knowledge and imperative knowledge. In mathematics we are usually concerned with declarative (what is) descriptions, whereas in computer science we are usually concerned with imperative (how to) descriptions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are two main thoughts I have about these passages.&lt;/p&gt;

&lt;p&gt;First, the distinction between declarative vs. procedural knowledge is philosophical interesting. It raises interesting questions about the relationship between these types of knowledge. The definitions of these two types of knowledge could probably use some further clarification, but once they are clarified, we can ask: Does procedural knowledge depend on declarative knowledge? Is it possible that procedural knowledge reduces to declarative knowledge? If we acknowledge something like procedural knowledge and it turns out that the knowledge doesn&amp;rsquo;t reduce to declarative knowledge, then are we committed to &lt;a href=&#34;http://plato.stanford.edu/entries/platonism/&#34;&gt;Platonism&lt;/a&gt; about algorithms? &lt;a href=&#34;http://www.philosophicalhacker.com/2014/04/22/why-im-glad-my-dream-job-didnt-work-out/&#34;&gt;My philosophy days are over&lt;/a&gt;, but it was interesting to briefly think about these questions anyway.&lt;/p&gt;

&lt;p&gt;Second, I think that this distinction means that some of our programming languages are misleading. Go, for example, uses the &lt;code&gt;func&lt;/code&gt; keyword to define a &amp;ldquo;function&amp;rdquo; in go. However, many of the functions we define in go are definitely not functions in the mathematical sense of the word, and as the above example points out, mathematical functions often fail to map neatly on to the stuff we put in our &lt;code&gt;func&lt;/code&gt; bodies.&lt;/p&gt;

&lt;h1 id=&#34;a-definition-of-syntax&#34;&gt;A definition of syntax&lt;/h1&gt;

&lt;p&gt;The authors do a great job of explaining what it means for a language to have a syntax. Crucial to understanding &amp;ldquo;syntax&amp;rdquo; is the idea of an &amp;ldquo;expression.&amp;rdquo; An expression is something that can be evaluated. Each type of expression has an evaluation rule. For example, the expression &lt;code&gt;42&lt;/code&gt; evaluates to &lt;code&gt;42&lt;/code&gt; in Lisp. So, the evaluation rule for the type of expression exemplified by &lt;code&gt;42&lt;/code&gt; must be something like &amp;ldquo;simply return the expression as is.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;A language has different types of expressions, and these other expression types have more complicated evaluation rules. For example, Lisp has expressions called &amp;ldquo;combinations.&amp;rdquo; Here&amp;rsquo;s an example of a combination:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(+ 1 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This combination evaluates to &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Combinations have a &lt;em&gt;recursive&lt;/em&gt; evaluation rule:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Evaluate the subexpressions of the combination.&lt;/li&gt;
&lt;li&gt;Apply the procedure that is the value of the leftmost subexpression (the operator) to the
arguments that are the values of the other subexpressions (the operands).&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now that we have a decent understanding of expressions, the author&amp;rsquo;s definition of syntax will (hopefully) be clear:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The various kinds of expressions (each with its associated evaluation rule)
constitute the syntax of the programming language.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;From this definition, I suspect that we can infer that there are at least two kinds of syntax errors:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Errors that result from using an expression type that is not recognized by the language. (E.g., try to use the keyword &lt;code&gt;func&lt;/code&gt; to define a method in Java)&lt;/li&gt;
&lt;li&gt;Errors that result from violating assumptions made by the evaluation rule for an expression. (E.g., try to use a non-final variable within a lamdba in Java)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These two kinds of errors seem to cover the syntax errors I&amp;rsquo;ve run into. Maybe there are more.&lt;/p&gt;

&lt;h1 id=&#34;code-is-data&#34;&gt;Code is data&lt;/h1&gt;

&lt;p&gt;Early on, the authors make a distinction between procedures and data:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In programming, we deal with two kinds of elements: procedures and data. (Later we will discover that they are really not so distinct.) Informally, data is ‘‘stuff’’ that we want to manipulate, and procedures are descriptions of the rules for manipulating the data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As you can see in this quote, however, the authors are quick to point out that the distinction between procedures and data is actually pretty tenuous. I don&amp;rsquo;t think I&amp;rsquo;ve made it to the point in the text where they explicitly say why the distinction doesn&amp;rsquo;t hold up, but there are few points in these sections that already suggest some important similarities between the two:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It can be helpful to think through the results of both procedures and data by using a substitution model.&lt;/li&gt;
&lt;li&gt;Defining variables names and procedure names both serve to make our code more abstract, thereby making it more manageable to write more complex programs.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>