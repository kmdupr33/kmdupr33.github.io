<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Philosophical Hacker</title>
    <link>https://www.philosophicalhacker.com/tags/go/index.xml</link>
    <description>Recent content on Philosophical Hacker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://www.philosophicalhacker.com/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Testing Package Implementation from &#39;the Outside&#39;</title>
      <link>https://www.philosophicalhacker.com/post/testing-package-implmentation-details-from-the-outside/</link>
      <pubDate>Wed, 03 Feb 2016 21:30:42 -0500</pubDate>
      
      <guid>https://www.philosophicalhacker.com/post/testing-package-implmentation-details-from-the-outside/</guid>
      <description>

&lt;p&gt;Sometimes you need to test a package&amp;rsquo;s implementation from outside of the package containing the implementation you&amp;rsquo;d like to test. This post briefly covers why this need arises and how we can meet  that need. Much of the information here is already covered in Andrew Gerrand&amp;rsquo;s &lt;a href=&#34;https://www.youtube.com/watch?v=ndmB0bj7eyw&#34;&gt;testing techniques talk&lt;/a&gt;, so if you&amp;rsquo;ve watched that, you&amp;rsquo;ll probably only think the last section of this post is interesting.&lt;/p&gt;

&lt;h3 id=&#34;why&#34;&gt;Why?&lt;/h3&gt;

&lt;p&gt;Like I just said, sometimes you need to test a package&amp;rsquo;s implementation from outside of the package containing the implementation you&amp;rsquo;d like to test. Typically, this situation happens because of circular dependency.&lt;/p&gt;

&lt;p&gt;For example, because the testing package depends on the fmt package, the standard library authors couldn&amp;rsquo;t place the tests for the fmt package within the fmt package itself without introducing a circular dependency. To avoid this circular dependency, the fmt tests are actually located in the fmt_test package.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t believe me? Have &lt;a href=&#34;https://github.com/golang/go/blob/master/src/fmt/fmt_test.go&#34;&gt;a look&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s another example: as I said in &lt;a href=&#34;http://www.philosophicalhacker.com/post/getting-started-with-gomock/&#34;&gt;my post on gomock&lt;/a&gt;, you can often wind up with circular dependencies while using gomock. You&amp;rsquo;re tests will depend on the package containing your mocks and your mocks will depend on the package containing the interfaces it mocks. If your tests are in the same package as the code you&amp;rsquo;re mocking, then you&amp;rsquo;ll introduce a circular dependency between package containing the code you want to test and the package containing your mocks. Again, the solution here is to move your tests outside of the package containing the code you want to test.&lt;/p&gt;

&lt;p&gt;Although the tests are outside of the package you are testing, you may still want to test the implementation details of that package. In other words, you may want to test parts of that package&amp;rsquo;s un-exported interface. For example, the authors of the standard library wanted to test the &lt;code&gt;isSpace()&lt;/code&gt; function from the fmt package.&lt;/p&gt;

&lt;h3 id=&#34;how&#34;&gt;How&lt;/h3&gt;

&lt;p&gt;In order to test the &lt;code&gt;isSpace()&lt;/code&gt; function from outside of the fmt package, the standard lib authors created a export_test.go file in the fmt package. This file simply exports the parts of the un-exported interface that they wanted to test:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//export_test.go&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;package&lt;/span&gt; fmt

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; IsSpace = isSpace
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This file ensures that the &lt;code&gt;isSpace()&lt;/code&gt; function is available to the fmt tests as &lt;code&gt;IsSpace()&lt;/code&gt;. Importantly, because this file has a _test.go prefix, it is only compiled when the &lt;code&gt;go test&lt;/code&gt; command is run, thereby ensuring that no clients outside of the testing package can access the &lt;code&gt;isSpace()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Sometimes, however, we want to test more than just an un-exported function from a package. Sometimes, we may want to test the methods of an un-exported struct. Say you&amp;rsquo;ve got a struct like &lt;code&gt;lruCache&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//cache.go&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; lruCache &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; {
	&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
}

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; (s &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;lruCache) GetGopher(name &lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;) (Gopher, &lt;span style=&#34;color: #B00040&#34;&gt;error&lt;/span&gt;) {
	gopher, ok &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; s.CachedGophers[name]
	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; !ok {
		&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; s.GopherFinder.Find(name)
	}
	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; gopher, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;nil&lt;/span&gt;
}

Now, suppose you wanted to test the &lt;span style=&#34;color: #BA2121&#34;&gt;`GetGopher()`&lt;/span&gt; method. This can be accomplished by combining the above technique with &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; embedding:
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//export_test.go&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; LRUCache &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; {
	lruCache
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, in order for this to work, the &lt;code&gt;GetGopher()&lt;/code&gt; method has to be exported. This doesn&amp;rsquo;t break encapsulation, however, because an exported method on an un-exported type will still be unaccessible to clients outside of the package.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;You just learned how to test package implementation details from &amp;ldquo;the outside.&amp;rdquo; This will come in handy when you break a circular dependency between your test code and the package you&amp;rsquo;re testing by placing the test code outside of the package you&amp;rsquo;re testing.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;re welcome.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Table-driven tests with Gomock</title>
      <link>https://www.philosophicalhacker.com/post/table-driven-tests-with-gomock/</link>
      <pubDate>Sat, 23 Jan 2016 13:01:07 -0500</pubDate>
      
      <guid>https://www.philosophicalhacker.com/post/table-driven-tests-with-gomock/</guid>
      <description>

&lt;p&gt;Table-driven tests are a common testing pattern for go tests. Since I recently started working with gomock, I wondered if there was a way to use table-driven tests with gomock mocks. It turns out that this is definitely possible, and that&amp;rsquo;s what this post is about. Before I show how to combine table-driven tests with gomock mocks, I briefly review how gomock and table-driven tests work and I try to show why you might want to combine table-driven tests with mocks in the first place.&lt;/p&gt;

&lt;h3 id=&#34;table-driven-tests&#34;&gt;Table-Driven Tests&lt;/h3&gt;

&lt;p&gt;There are many examples of table-driven tests in the standard library. One example of a table-driven test can be found in the &lt;code&gt;fmt_test&lt;/code&gt; package:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; fmtTests = []&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; {
	fmt &lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;
	val &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;interface&lt;/span&gt;{}
	out &lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;
}{
	{&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;12345&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;12345&amp;quot;&lt;/span&gt;},
	{&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;%v&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;12345&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;12345&amp;quot;&lt;/span&gt;},
	{&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;%t&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;},
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As the above code suggests, table-driven tests typically make use of slice literals of anonymous structs. The anonymous struct has fields that support various test cases. In this case, the fields are &lt;code&gt;fmt&lt;/code&gt;, the actual format specifier used within a format string, &lt;code&gt;val&lt;/code&gt;, the value formatted according to the format specifier, and &lt;code&gt;out&lt;/code&gt;, the string that is expected as a result of calling &lt;code&gt;fmt.Sprintf()&lt;/code&gt; on a formatted string with its specifiers and values.&lt;/p&gt;

&lt;p&gt;Within the &lt;code&gt;Test-&lt;/code&gt; method, the tests are run by ranging over the elements of the slice literal.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; TestSprintf(t &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;testing.T) {
	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; _, tt &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;range&lt;/span&gt; fmtTests {
&lt;span style=&#34;background-color: #ffffcc&#34;&gt;		s &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; Sprintf(tt.fmt, tt.val)
&lt;/span&gt;		&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
&lt;span style=&#34;background-color: #ffffcc&#34;&gt;		&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; s &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; tt.out {
&lt;/span&gt;			&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; _, ok &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; tt.val.(&lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;); ok {
				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Don&amp;#39;t requote the already-quoted strings.&lt;/span&gt;
				&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// It&amp;#39;s too confusing to read the errors.&lt;/span&gt;
				t.Errorf(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Sprintf(%q, %q) = &amp;lt;%s&amp;gt; want &amp;lt;%s&amp;gt;&amp;quot;&lt;/span&gt;, tt.fmt, tt.val, s, tt.out)
			} &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; {
				t.Errorf(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Sprintf(%q, %v) = %q want %q&amp;quot;&lt;/span&gt;, tt.fmt, tt.val, s, tt.out)
			}
		}
	}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;gomock-mocks&#34;&gt;Gomock Mocks&lt;/h3&gt;

&lt;p&gt;Gomock mocks are generated in two steps. The first step is to generate the mock code using the &lt;code&gt;mockgen&lt;/code&gt; command. The second step is to create the mock for use in your test:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;mockCtrl &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; gomock.NewController(t)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;defer&lt;/span&gt; mockCtrl.Finish()
mgf &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; mock_gopher.NewMockGopherFinder(mockCtrl)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If this snippet doesn&amp;rsquo;t make sense to you, it might be a good idea to read &lt;a href=&#34;http://www.philosophicalhacker.com/post/getting-started-with-gomock/&#34;&gt;my post on gomock&lt;/a&gt; before proceeding.&lt;/p&gt;

&lt;h3 id=&#34;why-bother&#34;&gt;Why bother?&lt;/h3&gt;

&lt;p&gt;To see why we might want to use table-driven tests with gomock, suppose we want to write a test for a cache of &lt;code&gt;Gopher&lt;/code&gt;s. When we ask the cache for a &lt;code&gt;Gopher&lt;/code&gt;, the cache will first check its own map to see if the &lt;code&gt;Gopher&lt;/code&gt; is available in memory. If the &lt;code&gt;Gopher&lt;/code&gt; is unavailable it will call on a &lt;code&gt;GopherFinder&lt;/code&gt; to fetch the &lt;code&gt;Gopher&lt;/code&gt; from some remote location:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; (s &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;lruCache) GetGopher(name &lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;) (Gopher, &lt;span style=&#34;color: #B00040&#34;&gt;error&lt;/span&gt;) {
	gopher, ok &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; s.CachedGophers[name]
	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; !ok {
		&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; s.GopherFinder.Find(name)
	}
	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; gopher, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;nil&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Suppose we want to test this behavior. There are two cases we want test:&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the first case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Given a Cache that does not contain the Gopher named &amp;quot;andrewgerrand&amp;quot;
When we ask the Cache for the Gopher named &amp;quot;andrewgerrand&amp;quot;
Then the Cache calls `Find()` on its `GopherFinder` to satisfy the request
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the second case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Given a Cache that does contain the Gopher named &amp;quot;andrewgerrand&amp;quot;
When we ask the Cache for the Gopher named &amp;quot;andrewgerrand&amp;quot;
Then the Cache doesn&#39;t call `Find()` on its `GohperFinder`. Instead, it returns a cached &amp;quot;andrewgerrand&amp;quot; `Gopher`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously, these test cases can share some code. Using a table-driven test can help us avoid duplicating the support code we need to execute these two test cases. Moreover, Cache&amp;rsquo;s, as &lt;a href=&#34;http://martinfowler.com/articles/mocksArentStubs.html&#34;&gt;Martin Fowler points out&lt;/a&gt;, are prime candidates for behavior/mock-based testing, so in this case, it doesn&amp;rsquo;t seem crazy to combine mocks with a table-driven test.&lt;/p&gt;

&lt;h3 id=&#34;putting-it-all-together&#34;&gt;Putting it All Together&lt;/h3&gt;

&lt;p&gt;The struct that supports the table-driven tests should contain fields for the values that need to change in order to support different, but related test cases. The first difference between our two cache test cases is that the in one case, the cache already contains a cached &lt;code&gt;Gopher&lt;/code&gt; for the name &amp;ldquo;andrewgerrand&amp;rdquo; and in the other case, it does not. So, our slice of anonymous structs should start off looking like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; cacheTests = []&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; {
	cachedGophers &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;]Gopher
	&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
}{
	{cachedGophers: &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;nil&lt;/span&gt;,
		&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
	},
	{cachedGophers: &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;]Gopher{&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;andrewgerrand&amp;quot;&lt;/span&gt;: Gopher{}},
		&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
	},
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When we range over the values of &lt;code&gt;cacheTests&lt;/code&gt;, we can use the value of the &lt;code&gt;cachedGophers&lt;/code&gt; field to setup our &lt;code&gt;Cache&lt;/code&gt; appropriately so we can test that it behaves correctly:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; TestCache(t &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;testing.T) {
    con &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; gomock.NewController(t)
	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; _, tt &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;range&lt;/span&gt; cacheTests {

		&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
		cache &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; NewLRUCache(mc)
&lt;span style=&#34;background-color: #ffffcc&#34;&gt;		cache.CachedGophers = tt.cachedGophers
&lt;/span&gt;
		cache.GetGopher(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;andrewgerrand&amp;quot;&lt;/span&gt;)
	}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The second thing that&amp;rsquo;s different about our two test cases is the actual calls we should expect on the &lt;code&gt;GohperFinder&lt;/code&gt;. Again, when the cache can&amp;rsquo;t find a &lt;code&gt;Gopher&lt;/code&gt; in memory, it should call on its &lt;code&gt;GopherFinder&lt;/code&gt;. Otherwise, it shouldn&amp;rsquo;t call the &lt;code&gt;GopherFinder&lt;/code&gt; at all, and it should simply return the &lt;code&gt;Gopher&lt;/code&gt; it has in memory. So, we need a field in our struct that captures this difference between the two test cases:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; cacheTests = []&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; {
	cachedGophers &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;]Gopher
	Configurer    Configurer
}{
    {cachedGophers: &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;nil&lt;/span&gt;,
		Configurer: &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt;(gf &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;MockGopherFinder) &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;MockGopherFinder {
			gf.EXPECT().
				Find(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;andrewgerrand&amp;quot;&lt;/span&gt;)
			&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; gf
		},
	},
	{cachedGophers: &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;]Gopher{&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;andrewgerrand&amp;quot;&lt;/span&gt;: Gopher{}},
		Configurer: &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt;(gf &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;MockGopherFinder) &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;MockGopherFinder {
			&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; gf
		},
	},
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;Configurer&lt;/code&gt;, as you probably figured out, is just a function that takes a mock as a parameter, configures it, and returns the configured mock to be used by the test. When &lt;code&gt;cachedGophers&lt;/code&gt; is nil, the &lt;code&gt;Cache&lt;/code&gt; created for the test won&amp;rsquo;t have any cached &lt;code&gt;Gophers&lt;/code&gt; in memory, so we should expect the &lt;code&gt;Cache&lt;/code&gt; to call &lt;code&gt;Find()&lt;/code&gt; on its &lt;code&gt;GopherFinder&lt;/code&gt;. On the other hand, the second struct has a &lt;code&gt;cachedGohpers&lt;/code&gt; map that should cause the &lt;code&gt;Cache&lt;/code&gt; to return a cached version of the &lt;code&gt;Gopher&lt;/code&gt; rather than fetch one from a remote location.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;TestCache()&lt;/code&gt; function can leverage the fields of this struct to run the two test cases:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; TestCache(t &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;testing.T) {

	con &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; gomock.NewController(t)
&lt;span style=&#34;background-color: #ffffcc&#34;&gt;	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; _, tt &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;range&lt;/span&gt; cacheTests {
&lt;/span&gt;
		mc &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; mock_gopher.NewMockGopherFinder(con)
&lt;span style=&#34;background-color: #ffffcc&#34;&gt;		mc = tt.Configurer(mc)
&lt;/span&gt;
		cache &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; NewLRUCache(mc)
&lt;span style=&#34;background-color: #ffffcc&#34;&gt;		cache.CachedGophers = tt.cachedGophers
&lt;/span&gt;
		cache.GetGopher(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;andrewgerrand&amp;quot;&lt;/span&gt;)
	}
	con.Finish()
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;what-do-you-think&#34;&gt;What do you think?&lt;/h3&gt;

&lt;p&gt;This strikes me as a fairly reasonable way of avoiding duplicating code while using gomock mocks in testing, but it might be silly and/or there might be a better solution. I&amp;rsquo;m interested in hearing alternative solutions to this problem, so I&amp;rsquo;d love to hear your thoughts on this. For the reasons I pointed out &lt;a href=&#34;http://www.philosophicalhacker.com/2016/01/13/should-we-use-mocking-libraries-for-go-testing/&#34;&gt;here&lt;/a&gt;, I don&amp;rsquo;t find the typical arguments offered against mocking libraries compelling, so I&amp;rsquo;m less interested in hearing people repeat those reasons, but if you have a novel reason for why gomock is a bad idea in the first place, I&amp;rsquo;d definitely like to hear it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Integration Tests in Go</title>
      <link>https://www.philosophicalhacker.com/post/integration-tests-in-go/</link>
      <pubDate>Fri, 22 Jan 2016 19:27:36 -0500</pubDate>
      
      <guid>https://www.philosophicalhacker.com/post/integration-tests-in-go/</guid>
      <description>

&lt;p&gt;Although Go has support for testing built in to its toolchain, certain kinds of testing can be a bit tricky. For example, it may not be immediately obvious how you would go about writing and running &lt;em&gt;integration tests&lt;/em&gt; in go. This post contains info on how to write and run integration tests for your go code.&lt;/p&gt;

&lt;h3 id=&#34;clarifying-terms&#34;&gt;Clarifying Terms&lt;/h3&gt;

&lt;p&gt;As &lt;a href=&#34;http://www.philosophicalhacker.com/2016/01/13/should-we-use-mocking-libraries-for-go-testing/&#34;&gt;I&amp;rsquo;ve said before&lt;/a&gt;, many terms in software are vague or ambiguous. So, before I get into how to write and run integration tests, let&amp;rsquo;s make sure we&amp;rsquo;re referring to the same thing when we use the word &amp;ldquo;integration&amp;rdquo; test. Sometimes it seems like people use &amp;ldquo;integration test&amp;rdquo; and &amp;ldquo;acceptance test&amp;rdquo; interchangeably. I do think, however, that there&amp;rsquo;s a useful distinction to be made between these types of tests, a distinction that&amp;rsquo;s made nicely by Steve Freeman and Nat Pryce in the following quotations:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Acceptance: Does the whole system work?&lt;/p&gt;

&lt;p&gt;Integration: Does our code work against code we can’t change?&lt;sup&gt;1&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Later on, they elaborate on the definition of an integration test:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We use the term integration tests to refer to the tests that check how some of our code works with code from outside the team that we can’t change. It might be a public framework, such as a persistence mapper, or a library from another team within our organization. The distinction is that integration tests make sure that any abstractions we build over third-party code work as we expect.&lt;sup&gt;2&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;integration-testing-in-go&#34;&gt;Integration Testing in Go&lt;/h3&gt;

&lt;p&gt;Now, that we&amp;rsquo;re clear on what we mean by the terms &amp;ldquo;acceptance&amp;rdquo; and &amp;ldquo;integration tests,&amp;rdquo; let&amp;rsquo;s briefly take a look at how we can write and run integration tests in go.&lt;/p&gt;

&lt;p&gt;Suppose you&amp;rsquo;re working with a database in your go code. Many databases have a go client sdk that you can use in your application. Typically, you&amp;rsquo;ll build some kind of abstraction on top of that sdk that your application will use to access and update the data in the database. This abstraction is a prime candidate for integration testing.&lt;/p&gt;

&lt;p&gt;Obviously, in order to perform this kind of integration testing, your go code needs to be able to communicate with the database. How can we ensure that there is a database available for our test code to talk to?&lt;/p&gt;

&lt;h4 id=&#34;a-naive-solution&#34;&gt;A naive solution&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;TestMain()&lt;/code&gt; function is a great way to perform the extra setup and teardown of your test database. When there&amp;rsquo;s a &lt;code&gt;TestMain()&lt;/code&gt; function in any of your test files, that function is called directly by &lt;code&gt;go test&lt;/code&gt;. The function can then perform any necessary setup, run the tests, and then teardown whatever was needed to support the tests:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; TestMain(m &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;testing.M) {
    setupDatabase()
    result &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; m.Run()
    teardownDatabase()
    os.Exit(result)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The problem with using &lt;code&gt;TestMain&lt;/code&gt; this way, however, is that integration tests are typically much slower than unit tests, so running our tests this way will make invocations of &lt;code&gt;go test&lt;/code&gt; take much longer. If we&amp;rsquo;re working on a part of the code that has nothing to do with integrating with 3rd party code, this can be pretty frustrating.&lt;/p&gt;

&lt;h4 id=&#34;a-less-naive-solution&#34;&gt;A less naive solution&lt;/h4&gt;

&lt;p&gt;Fortunately, the testing package itself suggests a solution to this problem. The testing package actually has a function called &lt;code&gt;testing.Short()&lt;/code&gt;. This function returns true if the &lt;code&gt;-short&lt;/code&gt; flag has been passed into the &lt;code&gt;go test&lt;/code&gt; command. Tests can check the value of &lt;code&gt;Short()&lt;/code&gt; to determine whether they should execute code and/or tests that will take a long time. This flag could be leveraged to determine whether the tests should spin up external services for integration tests:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; TestMain(m &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;testing.M) {
&lt;span style=&#34;background-color: #ffffcc&#34;&gt;    flag.Parse()
&lt;/span&gt;&lt;span style=&#34;background-color: #ffffcc&#34;&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; !testing.Short() {
&lt;/span&gt;&lt;span style=&#34;background-color: #ffffcc&#34;&gt;        setupDatabase()    
&lt;/span&gt;&lt;span style=&#34;background-color: #ffffcc&#34;&gt;    }
&lt;/span&gt;    result &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; m.Run()
&lt;span style=&#34;background-color: #ffffcc&#34;&gt;    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; !testing.Short() {
&lt;/span&gt;&lt;span style=&#34;background-color: #ffffcc&#34;&gt;        teardownDatabase()        
&lt;/span&gt;&lt;span style=&#34;background-color: #ffffcc&#34;&gt;    }    
&lt;/span&gt;    os.Exit(result)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The actual integration tests can check the value of &lt;code&gt;testing.Short()&lt;/code&gt; to see if they should execute:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; TestDatabaseGet(t &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;testing.T) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; testing.Short() {
        t.Skip()
    }
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id=&#34;a-scalable-solution&#34;&gt;A scalable solution&lt;/h4&gt;

&lt;p&gt;This solution is definitely better than just always setting up and tearing down a database in the &lt;code&gt;TestMain()&lt;/code&gt; function, but it has a few disadvantages:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It requires us to pass in the &lt;code&gt;-short&lt;/code&gt; flag every time we want to avoid running integration tests.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It doesn&amp;rsquo;t scale well to multiple types of integration tests.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Having to pass in the &lt;code&gt;-short&lt;/code&gt; flag whenever we want to avoid slow integration tests is inconvenient. Most of the time writing an application is probably spend writing code that isn&amp;rsquo;t covered by integration tests, so most of the time you&amp;rsquo;ll have to add the flag &lt;code&gt;-short&lt;/code&gt; to your &lt;code&gt;go test&lt;/code&gt; invocations.&lt;/p&gt;

&lt;p&gt;This inconvenience can be mitigated if we just tell our text editors to add the flag whenever they usually run &lt;code&gt;go test&lt;/code&gt; (e.g., on saving a file). However, since most of the time we aren&amp;rsquo;t interested in running integration tests, it seems like it would be better if &lt;code&gt;go test&lt;/code&gt; didn&amp;rsquo;t run integration tests by default. Instead, it&amp;rsquo;d be better if we had to explicitly tell &lt;code&gt;go test&lt;/code&gt; to run the integration tests.&lt;/p&gt;

&lt;p&gt;The second problem with using the &lt;code&gt;-short&lt;/code&gt; flag is that it doesn&amp;rsquo;t scale well to multiple types of integration tests. Suppose, for example, that our code utilized a database and a message queue. We can ensure that both our database and message queues are setup if we&amp;rsquo;re doing both types of integration tests, but if we just want to run the integration tests for our database and not for our message queue, we are again forced to wait longer for our tests to run.&lt;/p&gt;

&lt;p&gt;The solution to both of these problems is to use custom flags. You can pass custom flags into the &lt;code&gt;go test&lt;/code&gt; command and handle them however you like within your tests. We can define a flag for database integration tests and a flag for message queue tests and only run the respective integration tests when those flags are passed in. For example, &lt;code&gt;go test -database&lt;/code&gt; will only run the database-related integration tests and: &lt;code&gt;go test -queue&lt;/code&gt; will only run the message-queue-related integration tests.&lt;/p&gt;

&lt;p&gt;Briefly, here&amp;rsquo;s how you could support that behavior in &lt;code&gt;TestMain()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;var&lt;/span&gt; (
    database = flag.Bool(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;database&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;run database integration tests&amp;quot;&lt;/span&gt;)    
    messageQueue = flag.Bool(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;messageQueue&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;run message queue integration tests&amp;quot;&lt;/span&gt;)
)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; TestMain(m &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;testing.M) {
    flag.Parse()
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;database {
        setupDatabase()    
    }
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;messageQueue {
        setupMessageQueue()
    }
    result &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; m.Run()
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;database {
        teardownDatabase()        
    }
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;messageQueue {
        teardownMessageQueue()
    }    
    os.Exit(result)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Of course, your database and message queue integration tests should also check for these flags and skip if they are not set to true.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve just seen three ways of writing and running integration tests in go.&lt;/p&gt;

&lt;p&gt;The first way was to simply use the &lt;code&gt;TestMain()&lt;/code&gt; function to perform whatever setup and teardown you need for your tests. I called this solution &amp;ldquo;naive&amp;rdquo; because it dramatically increases the time it takes for &lt;code&gt;go test&lt;/code&gt; to execute, even if you aren&amp;rsquo;t interested in running integration tests.&lt;/p&gt;

&lt;p&gt;The second &amp;ldquo;less naive&amp;rdquo; solution was to take advantage of the &lt;code&gt;-short&lt;/code&gt; flag built in to the testing package. This solution is better because it gives us a way of shortening our test runs when we don&amp;rsquo;t want to run integration tests. However, this solution forces us to pass the &lt;code&gt;-short&lt;/code&gt; flag whenever we want to shorten our test run, and since we aren&amp;rsquo;t usually interested in running integration tests, this is inconvenient. Moreover, this solution doesn&amp;rsquo;t give us fine-grained control over which kinds of integration tests we want to run, and this again forces us to wait longer for &lt;code&gt;go test&lt;/code&gt; to complete.&lt;/p&gt;

&lt;p&gt;I believe that the last solution we explored is a very scalable way of handling integration testing in go. It gives us fine-grained control over which integration tests we want to run and doesn&amp;rsquo;t run any slow integration tests by default. This allows us to run our tests as quickly as possible. I also suspect that there&amp;rsquo;s another advantage to using custom flags for your integration testing: it makes acceptance testing easier, but this something that I&amp;rsquo;ll have to explore another time.&lt;/p&gt;

&lt;h4 id=&#34;notes&#34;&gt;Notes:&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627&#34;&gt;Growing Object Oriented Software Guided by Tests&lt;/a&gt;, pg 40-41&lt;/li&gt;
&lt;li&gt;Ibid., pg 41-42&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with Gomock</title>
      <link>https://www.philosophicalhacker.com/post/getting-started-with-gomock/</link>
      <pubDate>Wed, 20 Jan 2016 10:43:26 -0500</pubDate>
      
      <guid>https://www.philosophicalhacker.com/post/getting-started-with-gomock/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;http://www.philosophicalhacker.com/2016/01/13/should-we-use-mocking-libraries-for-go-testing&#34;&gt;my last post&lt;/a&gt;, I talked about why I started using gomock, a mocking library that facilitates testing in go. If you found what I said in that post at all compelling, you might have decided to give gomock a try and you might have noticed that the documentation isn&amp;rsquo;t as helpful as it could be. This post is meant to supplement the documentation. It&amp;rsquo;s a brief tutorial on how to get started with gomock.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;your-first-mock-utilizing-test&#34;&gt;Your first mock-utilizing test&lt;/h3&gt;

&lt;p&gt;To get started using gomock, first follow the installation instructions laid out in the gomock &lt;a href=&#34;https://github.com/golang/mock&#34;&gt;repo&amp;rsquo;s readme&lt;/a&gt;. Once you&amp;rsquo;ve installed gomock, you can start generating mocks for your tests. Let&amp;rsquo;s explore how gomock works with an example.&lt;/p&gt;

&lt;p&gt;Suppose you&amp;rsquo;re writing a simple server that allows users to lookup go programmers (gophers) by name. The handler function for that server might look something like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; FindHandler(gf GopherFinder) http.HandlerFunc {

	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt;(w http.ResponseWriter, r &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;http.Request) {

		gopher, err &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; gf.Find(r.URL.Path[&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;:])
		&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;nil&lt;/span&gt; {
			w.WriteHeader(&lt;span style=&#34;color: #666666&#34;&gt;500&lt;/span&gt;)
			&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt;
		}

		gopherBytes, err &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; json.Marshal(gopher)
		&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;nil&lt;/span&gt; {
			w.WriteHeader(&lt;span style=&#34;color: #666666&#34;&gt;500&lt;/span&gt;)
			&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt;
		}

		w.Write(gopherBytes)
	}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, say we want to write a unit test that ensures that this function works properly. The first thing that this function should do is pull the gopher&amp;rsquo;s name data off of the &lt;code&gt;Request&lt;/code&gt; struct and pass that name into the &lt;code&gt;Find()&lt;/code&gt; method of the &lt;code&gt;GopherFinder&lt;/code&gt;. With Gomock, we can create a mock &lt;code&gt;GopherFinder&lt;/code&gt; that will fail the test if it does not receive a call to &lt;code&gt;Find()&lt;/code&gt; with the appropriate arguments.&lt;/p&gt;

&lt;p&gt;First, we generate the file that will allow us to mock &lt;code&gt;GopherFinder&lt;/code&gt; by running following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mockgen -destination mock_gopher_finder.go \
github.com/kmdupr33/philhackerblogcode \
GopherFinder
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command takes two arguments. The first argument is an import path leading to the &lt;em&gt;interfaces&lt;/em&gt; that you want to mock. The second argument is a comma separate list of interfaces to mock.&lt;sup&gt;1&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The command also takes several flags, but the most import flag to pass in is the &lt;code&gt;-destination&lt;/code&gt; flag. This flag specifies the the file you want the mock source code to live in. Without this flag, the generated mock code is simply printed to standard output.&lt;/p&gt;

&lt;p&gt;Now that we&amp;rsquo;ve generated the code to support our mock &lt;code&gt;GopherFinder&lt;/code&gt;, we can create a mock for a test of the &lt;code&gt;FindHandler&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;package&lt;/span&gt; philhackerblogcode_test

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; (
	&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;

	. &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;github.com/kmdupr33/philhackerblogcode&amp;quot;&lt;/span&gt;

	&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
	&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;github.com/kmdupr33/philhackerblogcode/mock_philhackerblogcode&amp;quot;&lt;/span&gt;
)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; TestHandler(t &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;testing.T) {

	mockCtrl &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; gomock.NewController(t)
	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;defer&lt;/span&gt; mockCtrl.Finish()
	mgf &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; mock_philhackerblogcode.NewMockGopherFinder(mockCtrl)
&lt;span style=&#34;background-color: #ffffcc&#34;&gt;	mgf.EXPECT().Find(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;andrewgerrand&amp;quot;&lt;/span&gt;)
&lt;/span&gt;
	h &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; FindHandler(mgf)

	wr &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; httptest.NewRecorder()
	url, _ &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; url.Parse(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;http://gopherfinder.com/andrewgerrand&amp;quot;&lt;/span&gt;)
	r &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;http.Request{URL: url}

	h(wr, r)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The highlighted line above is the call where you actually specify which methods the mock &lt;code&gt;GopherFinder&lt;/code&gt; is expecting to receive during the test. Here we tell the mock that we&amp;rsquo;re expecting a call to the &lt;code&gt;Find()&lt;/code&gt; method with an argument of &amp;ldquo;andrewgerrand.&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;handling-circular-dependencies&#34;&gt;Handling Circular Dependencies&lt;/h1&gt;

&lt;p&gt;Notice that the package for the above snippet of code is &lt;code&gt;philhackerblogcode_test&lt;/code&gt; instead of &lt;code&gt;philhackerblogcode&lt;/code&gt;. Typically, tests are placed in the same package as the code that those tests exercise, but if you do this when using gomock you are probably going to introduce a circular dependency between the package you are testing and the package that contains the generated mock code.&lt;/p&gt;

&lt;p&gt;The mockgen commmand generates files that are in the package mock_&amp;lt;package_containing_interfaces_to_be_mocked&amp;gt;. The mock package generated by mockgen will likely depend on the package that you&amp;rsquo;re testing and the package you are testing, if the tests live in that package, will depend on the mock package.&lt;/p&gt;

&lt;p&gt;The way to avoid this circular dependency is to place your tests in a package that&amp;rsquo;s different from the package you are testing. Next, have your test code import both the package you&amp;rsquo;d like to test and the mock package that the test depends upon. As Andrew Gerrand points out in his &lt;a href=&#34;https://www.youtube.com/watch?v=ndmB0bj7eyw&#34;&gt;testing techniques talk&lt;/a&gt;, this is a standard way of avoiding circular circular dependencies while testing.&lt;/p&gt;

&lt;h1 id=&#34;stubbing-with-gomock&#34;&gt;Stubbing with gomock&lt;/h1&gt;

&lt;p&gt;The above test ensures that the &lt;code&gt;HandlerFunc&lt;/code&gt; returned by &lt;code&gt;GetHandler&lt;/code&gt; calls the &lt;code&gt;GopherFinder&lt;/code&gt; with the appropriate arguments, but the &lt;code&gt;HandlerFunc&lt;/code&gt; has more behavior that we can test. One of the things the &lt;code&gt;HandlerFunc&lt;/code&gt; should do is respond with a 500 if the &lt;code&gt;GopherFinder&lt;/code&gt; returns an error while finding a gopher. In order to test this additional behavior, we need to force the &lt;code&gt;GopherFinder&lt;/code&gt; to return an error for the purposes of the test.&lt;/p&gt;

&lt;p&gt;Fortunately, Gomock also allows us to do exactly this. It allows the mocks it generates to behave like stubs.&lt;sup&gt;2&lt;/sup&gt; You can specify the return value that should be returned by using the &lt;code&gt;Return()&lt;/code&gt; method on the result of calling &lt;code&gt;EXPECT()&lt;/code&gt; and the method you are expecting:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; TestHandler(t &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;testing.T) {
	&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
	mgf &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; mock_philhackerblogcode.NewMockGopherFinder(mockCtrl)
&lt;span style=&#34;background-color: #ffffcc&#34;&gt;	mgf.EXPECT().
&lt;/span&gt;&lt;span style=&#34;background-color: #ffffcc&#34;&gt;		Find(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;andrewgerrand&amp;quot;&lt;/span&gt;).
&lt;/span&gt;&lt;span style=&#34;background-color: #ffffcc&#34;&gt;		Return(Gopher{}, errors.New(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;error for test purposes&amp;quot;&lt;/span&gt;))
&lt;/span&gt;
	&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;

	wr &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; httptest.NewRecorder()
	&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//...&lt;/span&gt;
	r &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;http.Request{URL: url}

	h(wr, r)

&lt;span style=&#34;background-color: #ffffcc&#34;&gt;	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; wr.Code &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;500&lt;/span&gt; {
&lt;/span&gt;&lt;span style=&#34;background-color: #ffffcc&#34;&gt;		t.Errorf(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Expected code: %d, actual code: %d&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;500&lt;/span&gt;, wr.Code)
&lt;/span&gt;&lt;span style=&#34;background-color: #ffffcc&#34;&gt;	}
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Because we&amp;rsquo;ve told the mock &lt;code&gt;GopherFinder&lt;/code&gt; to return an error when its &lt;code&gt;Find()&lt;/code&gt; method is called, we can test to see that the &lt;code&gt;HandlerFunc&lt;/code&gt; actually writes out a 500 response code when the &lt;code&gt;GopherFinder&lt;/code&gt; returns an error.&lt;/p&gt;

&lt;h2 id=&#34;notes&#34;&gt;Notes&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The mockgen command can also be run in &amp;ldquo;source mode.&amp;rdquo; In source mode, you simply pass in the source file containing interfaces to be mocked as an argument. See &lt;a href=&#34;https://github.com/golang/mock#running-mockgen&#34;&gt;the docs&lt;/a&gt; for more info.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For more on the difference between mocks and stubs, see Martin Fowler&amp;rsquo;s &lt;a href=&#34;http://martinfowler.com/articles/mocksArentStubs.html&#34;&gt;Mocks aren&amp;rsquo;t Stubs&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Should we use mocking libraries for go testing?</title>
      <link>https://www.philosophicalhacker.com/2016/01/13/should-we-use-mocking-libraries-for-go-testing/</link>
      <pubDate>Thu, 14 Jan 2016 02:20:53 +0000</pubDate>
      
      <guid>https://www.philosophicalhacker.com/2016/01/13/should-we-use-mocking-libraries-for-go-testing/</guid>
      <description>&lt;p&gt;A few weeks ago, I started learning go. Since I&amp;rsquo;m a wannabe TDD-er, I took a look at some resources on testing go code. I stumbled upon &lt;a href=&#34;https://talks.golang.org/2014/testing.slide#1&#34;&gt;Andrew Gerrand&amp;rsquo;s excellent Testing Techniques talk&lt;/a&gt; in which he says this:&lt;/p&gt;

&lt;blockquote&gt;Go eschews a lot of things, including mocks and fakes.&lt;/blockquote&gt;

&lt;p&gt;&amp;ldquo;Alright cool,&amp;rdquo; I thought to myself. I&amp;rsquo;m down to &amp;ldquo;do as the gophers do&amp;rdquo; and eschew mocks. Later on during his talk, Andrew Gerrand mentions &lt;a href=&#34;https://github.com/golang/mock&#34;&gt;gomock&lt;/a&gt;, a mocking library, and reluctantly says&lt;/p&gt;

&lt;blockquote&gt;[mocking libraries like gomock] are fine, but I find that on balance the hand-written fakes tend be easier to reason about and clearer to see what&#39;s going on, but I&#39;m not an enterprise go programmer so maybe people do need that so I don&#39;t know, but that&#39;s my advice.&lt;/blockquote&gt;

&lt;p&gt;Of course, after hearing that, I felt a little confused and unsure whether I should refrain from using mocking libraries in go. To make matters worse, I took a look at gomock and was surprised to find that its written by two engineers at Google.&lt;/p&gt;

&lt;p&gt;At that point, it seemed that the question of whether we should use a mocking library while testing go code is a bit of a contentious question, even within Google. I found the seeming contentious nature of this question pretty unhelpful and confusing when I was trying to get a handle on how to write good go code. However, it led me to do some research on the pros and cons of mocking libraries vs hand-written mocks, and in this post, I present the conclusions I came to based on my research:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The apparent contentiousness about whether to use use a mocking library if probably partially due to vague terminology.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If we are clear about our terms, the argument against using mocking libraries is not very compelling.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;vague-terms&#34;&gt;Vague Terms&lt;/h1&gt;

&lt;p&gt;I think the terms &amp;ldquo;mock&amp;rdquo; and &amp;rdquo;fake,&amp;rdquo; like many terms in software, are vague. I think, moreover, that the vagueness of the terms makes the question of whether to use a mocking library more difficult and more apparently contentious than it actually is.&lt;/p&gt;

&lt;p&gt;Before I say more, let me start by giving a clear definition of a &amp;ldquo;mock.&amp;ldquo; I like Martin Fowler&amp;rsquo;s definition of mocks, a definition that he takes from Gerard Meszaros, the author of &lt;a href=&#34;http://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054&#34;&gt;xUnit Test Patterns&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;objects pre-programmed with expectations which form a specification of the calls they are expected to receive [during the test]&lt;/blockquote&gt;

&lt;p&gt;Here&amp;rsquo;s what a quick and dirty (hand-rolled) mock might look like in go:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; mockEmailSender &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; {
	test        &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;testing.T
	sendCalled  &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;
	sendSubject &lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;
	sendBody    &lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;
}

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; (m &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;mockEmailSender) Send(subject &lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;, body &lt;span style=&#34;color: #B00040&#34;&gt;string&lt;/span&gt;) {
	m.sendCalled = &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;true&lt;/span&gt;
	m.sendSubject = subject
	m.sendBody = body
}

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; (m mockEmailSender) verifyExpectation() {
	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; !m.sendCalled {
		m.test.Error(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Expected call to Send()&amp;quot;&lt;/span&gt;)
	}

	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; m.sendSubject &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Should we use mocking libraries?&amp;quot;&lt;/span&gt; {
		m.test.Errorf(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Expeced Send() with subject: %s, received: %s&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Should we use mocking libraries?&amp;quot;&lt;/span&gt;, m.sendSubject)
	}

	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; m.sendBody &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Probably&amp;quot;&lt;/span&gt; {
		m.test.Errorf(&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Expected Send() with body: %s, received: %s&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Probably&amp;quot;&lt;/span&gt;, m.sendBody)
	}

}

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;func&lt;/span&gt; TestEmailSender(t &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;testing.T) {
	m &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; mockEmailSender{test: t}
	&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;defer&lt;/span&gt; m.verifyExpectation()
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Of course, this is a contrived example, but its enough to help convey the idea of a mock. As you can see, the test will fail if the mock doesn&amp;rsquo;t receive a call with the appropriate arguments. The mock has been &amp;ldquo;pre-programmed&amp;rdquo; to expect a call to Send() with specific arguments and that expectation must be fulfilled in order for the test to pass.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s quickly define another word: &amp;ldquo;test double.&amp;rdquo; Test doubles are objects that are used instead of a &amp;ldquo;real object&amp;rdquo; to facilitate testing. A mock is a test double, but not all test doubles are mocks.&lt;/p&gt;

&lt;p&gt;Now that I&amp;rsquo;ve clarified the terms &amp;ldquo;mock&amp;rdquo; and &amp;ldquo;test double,&amp;rdquo; let me say a little about why I think these terms are confused in Gerrand&amp;rsquo;s testing techniques talk. I think that Gerrand is using the terms &amp;ldquo;mock&amp;rdquo; and &amp;ldquo;fake&amp;rdquo; to refer to test doubles in general rather than mocks in Fowler&amp;rsquo;s sense of the word. If people are using the word &amp;ldquo;mock&amp;rdquo; to talk about different things, then we have to be careful about how we interpret their arguments for or against &amp;ldquo;mocking&amp;rdquo; libraries.&lt;/p&gt;

&lt;p&gt;A part of the reason I think that Gerrand is using the term &amp;ldquo;mock&amp;rdquo; and &amp;ldquo;fake&amp;rdquo; differently from mock enthusiasts is that there&amp;rsquo;s been some confusion about the term &amp;ldquo;mock&amp;rdquo; in the past, even among seasoned, intelligent software engineers like Andrew Gerrand. For example, Martin Fowler wrote &lt;a href=&#34;http://martinfowler.com/articles/mocksArentStubs.html&#34;&gt;&amp;ldquo;Mocks aren&amp;rsquo;t Stubs&amp;rdquo;&lt;/a&gt; to clear up some confusion about the distinction between &amp;ldquo;mocks&amp;rdquo; and &amp;ldquo;stubs.&amp;rdquo; Moreover, Steve Freeman, the author of &lt;a href=&#34;http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627&#34;&gt;Growing Object Oriented Software Guided by Tests&lt;/a&gt;, accuses Robert Martin of conflating mocks with stubs in his &lt;a href=&#34;https://sites.google.com/site/unclebobconsultingllc/blogs-by-robert-martin/manual-mocking-resisting-the-invasion-of-dots-and-parentheses&#34;&gt;&amp;ldquo;Manual Mocking: Resisting the Invasion of Dots and Parentheses.&amp;ldquo;¹&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Another reason I think that Gerrand uses the word &amp;ldquo;mock&amp;rdquo; or &amp;ldquo;fake,&amp;rdquo; to refer to what Fowler would call a &amp;rdquo;test double,&amp;rdquo; is that he says,&lt;/p&gt;

&lt;blockquote&gt;We just have small fakes like the [httptest.]ResponseRecorder that allow us to inspect how they were used. There are frameworks that generate those kinds of fakes. One of them is called &#34;gomock...&#34;&lt;/blockquote&gt;

&lt;p&gt;However, the &amp;ldquo;fakes&amp;rdquo; generated by gomock are importantly different from ResponseRecorder. Gomock generates mocks in Fowler&amp;rsquo;s sense of the word, which means that the test that contains the mock will only pass if the the object being tested &lt;em&gt;calls the expected methods of the mock object&lt;/em&gt;. (Think back to above &amp;ldquo;hand-rolled&amp;rdquo; mock.)&lt;/p&gt;

&lt;p&gt;This isn&amp;rsquo;t how tests with a ResponseRecorder work out of the box. In fact, the ResponseRecorder is basically a Recorder with some &amp;ldquo;getters&amp;rdquo; that allow us to perform state-based verification for our testing, a verification technique that, according to Martin Fowler, is a verification technique that&amp;rsquo;s used when you &lt;em&gt;aren&amp;rsquo;t&lt;/em&gt; working with a mock.&lt;/p&gt;

&lt;h1 id=&#34;the-argument-against-gomock&#34;&gt;The Argument against Gomock&lt;/h1&gt;

&lt;p&gt;Regardless of whether there&amp;rsquo;s any confusion of terms in Gerrand&amp;rsquo;s remarks about mocking, if we&amp;rsquo;re clear about what we mean by mocks, I think we can see that his reasons against using a mocking library aren&amp;rsquo;t very compelling. Recall that his reason to write hand-written mocks is that they tend to be:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;easier to reason about&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;easier to read&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This argument raises two questions. First, is it really the case the handwritten mocks are easier to read and reason about? Second, even if they are easier to read and reason about, is it worth hand writing the mocks when they can generated by a library?&lt;/p&gt;

&lt;p&gt;The first question raises hard questions about how you would &amp;ldquo;objectively&amp;rdquo; measure the readability and &amp;ldquo;reasonableness&amp;rdquo; of code. I&amp;rsquo;m not prepared to answer those questions here. I can say, however, that, in my experience, mocks whose expectations can be set within the test body are easier to read and reason about. Gomock lets you generate these kinds of mocks, so that&amp;rsquo;s a point for gomock in my book.&lt;/p&gt;

&lt;p&gt;The second question is easier for me to answer. Of all the test doubles, mocks are probably the most tedious to write. Its not implausible that increased readability might justify hand-rolling other kinds of test doubles, but mocks aren&amp;rsquo;t completely trivial to write, so I&amp;rsquo;d rather have a library that does that for me, &lt;em&gt;even if the library mocks are a little less readable.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;So, that&amp;rsquo;s where I stand for now. I think that if you&amp;rsquo;re going to use mocks for your tests, using a mocking library is probably a good idea. Moreover, I think that a part of the reason why it can be difficult to come to this conclusion is that we often aren&amp;rsquo;t very clear about how we use words like &amp;ldquo;mock&amp;rdquo; and &amp;ldquo;fake.&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;notes&#34;&gt;Notes&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Steve Freeman claims that Robert Martin conflates mocks with stubs in the comments of Robert Martin&amp;rsquo;s article.&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
  </channel>
</rss>